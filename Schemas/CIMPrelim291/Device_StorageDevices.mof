// ===================================================================
// Title:  Storage Devices
// $State: Exp $
// $Date: 2005/02/24 20:05:58 $
// $Source: /cvs/MSB/pegasus/Schemas/CIMPrelim291/Attic/Device_StorageDevices.mof,v $
// $Revision: 1.1 $
// ===================================================================
//#pragma inLine ("Includes/copyright.inc")
// Copyright 1998-2005 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.
// DMTF is a not-for-profit association of industry members dedicated
// to promoting enterprise and systems management and interoperability.
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members,
// provided that correct attribution is given.
// As DMTF specifications may be revised from time to time,
// the particular version and release date should always be noted.
// 
// Implementation of certain elements of this standard or proposed
// standard may be subject to third party patent rights, including
// provisional patent rights (herein "patent rights"). DMTF makes
// no representations to users of the standard as to the existence
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or
// claimants, nor for any incomplete or inaccurate identification or
// disclosure of such rights, owners or claimants. DMTF shall have no
// liability to any party, in any manner or circumstance, under any
// legal theory whatsoever, for failure to recognize, disclose, or
// identify any such third party patent rights, or for such party's
// reliance on the standard or incorporation thereof in its product,
// protocols or testing procedures. DMTF shall have no liability to
// any party implementing such standard, whether such implementation
// is foreseeable or not, nor to any patent owner or claimant, and shall
// have no liability or responsibility for costs or losses incurred if
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the
// standard from any and all claims of infringement by a patent owner
// for such implementations.
// 
// For information about patents held by third-parties which have
// notified the DMTF that, in their opinion, such patent may relate to
// or impact implementations of DMTF standards, visit
// http://www.dmtf.org/about/policies/disclosures.php.
//#pragma inLine
// ===================================================================
// Description: The Device Model extends the management concepts that
//              are related to LogicalDevices. This file defines
//              the management of storage devices (floppies,
//              CD-ROMs, hard drives, etc.).
// 
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined
//              by other working groups, are omitted.
// ==================================================================
// Change Log for v2.9 Preliminary Company Review
// CR1456 - Updates plus typo fixes for multipath interfaces
// CR1465 - Corrected compile errors and warnings.
// 
// Change Log for v2.9 preliminary:
// CR1334 : Addition of storage multipath model.

// Change Log for v2.8 Final:
// CR1233 - SysDev omnibus CR - minor MOF corrections
// 
// Change Log for v2.7 Final
// CR970 - Removal of the Experimental qualifier
// 
// Change Log for v2.7
// CR721 - Add DeviceErrorCountData that is part of the new statistics
//         hierarchy
// ==================================================================

#pragma locale ("en_US")


// ===================================================================
// MediaAccessDevice
// ===================================================================
   [Version ( "2.6.0" ), Description (
       "A MediaAccessDevice represents the ability to access one or "
       "more media and use this media to store and retrieve data.")]
class CIM_MediaAccessDevice : CIM_LogicalDevice {

      [Description (
          "Capabilities of the MediaAccessDevice. For example, the "
          "Device may support \"Random Access\", removeable media and "
          "\"Automatic Cleaning\". In this case, the values 3, 7 and 9 "
          "would be written to the array. \n"
          "Several of the enumerated values require some explanation: "
          "1) Value 11, Supports Dual Sided Media, distinguishes a "
          "Device that can access both sides of dual sided Media, from "
          "a Device that reads only a single side and requires the "
          "Media to be flipped; and, 2) Value 12, Predismount Eject "
          "Not Required, indicates that Media does not have to be "
          "explicitly ejected from the Device before being accessed by "
          "a PickerElement."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
          "10", "11", "12" }, 
       Values { "Unknown", "Other", "Sequential Access",
          "Random Access", "Supports Writing", "Encryption",
          "Compression", "Supports Removeable Media",
          "Manual Cleaning", "Automatic Cleaning", 
          // 10                           
          "SMART Notification", "Supports Dual Sided Media",
          "Predismount Eject Not Required" }, 
       MappingStrings { "MIF.DMTF|Storage Devices|001.9",
          "MIF.DMTF|Storage Devices|001.11",
          "MIF.DMTF|Storage Devices|001.12", "MIF.DMTF|Disks|003.7",
          "MIF.DMTF|Host Disk|001.2", "MIF.DMTF|Host Disk|001.4" },
       ArrayType ( "Indexed" ), 
       ModelCorrespondence { 
          "CIM_MediaAccessDevice.CapabilityDescriptions" }]
   uint16 Capabilities[];

      [Description (
          "An array of free-form strings providing more detailed "
          "explanations for any of the AccessDevice features indicated "
          "in the Capabilities array. Note, each entry of this array "
          "is related to the entry in the Capabilities array that is "
          "located at the same index."), 
       ArrayType ( "Indexed" ), 
       ModelCorrespondence { "CIM_MediaAccessDevice.Capabilities" }]
   string CapabilityDescriptions[];

      [Description (
          "ErrorMethodology is a free-form string describing the "
          "type(s) of error detection and correction supported by this "
          "Device.")]
   string ErrorMethodology;

      [Description (
          "A free form string indicating the algorithm or tool used by "
          "the device to support compression. If it is not possible or "
          "not desired to describe the compression scheme (perhaps "
          "because it is not known), recommend using the following "
          "words: \"Unknown\" to represent that it is not known "
          "whether the device supports compression capabilities or "
          "not, \"Compressed\" to represent that the device supports "
          "compression capabilities but either its compression scheme "
          "is not known or not disclosed, and \"Not Compressed\" to "
          "represent that the devices does not support compression "
          "capabilities.")]
   string CompressionMethod;

      [Description (
          "When the MediaAccessDevice supports multiple individual "
          "Media, this property defines the maximum number which can "
          "be supported or inserted.")]
   uint32 NumberOfMediaSupported;

      [Description (
          "Maximum size, in KBytes, of media supported by this Device. "
          "KBytes is interpreted as the number of bytes multiplied by "
          "1000 (NOT the number of bytes multiplied by 1024)."), 
       MappingStrings { "MIF.DMTF|Sequential Access Devices|001.2",
          "MIF.DMTF|Host Disk|001.5" }]
   uint64 MaxMediaSize;

      [Description (
          "Default block size, in bytes, for this Device."), 
       Units ( "Bytes" )]
   uint64 DefaultBlockSize;

      [Description (
          "Maximum block size, in bytes, for media accessed by this "
          "Device."), 
       Units ( "Bytes" )]
   uint64 MaxBlockSize;

      [Description (
          "Minimum block size, in bytes, for media accessed by this "
          "Device."), 
       Units ( "Bytes" )]
   uint64 MinBlockSize;

      [Description (
          "Boolean indicating that the MediaAccessDevice needs "
          "cleaning. Whether manual or automatic cleaning is possible "
          "is indicated in the Capabilities array property.")]
   boolean NeedsCleaning;

      [Description (
          "True indicates that the media is locked in the Device and "
          "can not be ejected. For non-removeable Devices, this value "
          "should be true.")]
   boolean MediaIsLocked;

      [Description (
          "An enumeration indicating the operational security defined "
          "for the MediaAccessDevice. For example, information that "
          "the Device is \"Read Only\" (value=4) or \"Boot Bypass\" "
          "(value=6) can be described using this property."), 
       ValueMap { "1", "2", "3", "4", "5", "6", "7" }, 
       Values { "Other", "Unknown", "None", "Read Only", "Locked Out",
          "Boot Bypass", "Boot Bypass and Read Only" }, 
       MappingStrings { "MIF.DMTF|Disks|003.22" }]
   uint16 Security;

      [Description (
          "The date and time on which the Device was last cleaned.")]
   datetime LastCleaned;

      [Description (
          "Time in milliseconds to move from the first location on the "
          "Media to the location that is furthest with respect to "
          "time. For a DiskDrive, this represents full seek + full "
          "rotational delay. For TapeDrives, this represents a search "
          "from the beginning of the tape to the most physically "
          "distant point. (The end of a tape may be at its most "
          "physically distant point, but this is not necessarily "
          "true.)"), 
       Units ( "MilliSeconds" )]
   uint64 MaxAccessTime;

      [Description (
          "The sustained data transfer rate in KB/sec that the Device "
          "can read from and write to a Media. This is a sustained, "
          "raw data rate. Maximum rates or rates assuming compression "
          "should not be reported in this property."), 
       Units ( "KiloBytes per Second" )]
   uint32 UncompressedDataRate;

      [Description (
          "Time in milliseconds from 'load' to being able to read or "
          "write a Media. For example, for DiskDrives, this is the "
          "interval between a disk not spinning to the disk reporting "
          "that it is ready for read/write (ie, the disk spinning at "
          "nominal speeds). For TapeDrives, this is the time from a "
          "Media being injected to reporting that it is ready for an "
          "application. This is usually at the tape's BOT area."), 
       Units ( "MilliSeconds" )]
   uint64 LoadTime;

      [Description (
          "Time in milliseconds from being able to read or write a "
          "Media to its 'unload'. For example, for DiskDrives, this is "
          "the interval between a disk spinning at nominal speeds and "
          "a disk not spinning. For TapeDrives, this is the time for a "
          "Media to go from its BOT to being fully ejected and "
          "accessible to a PickerElement or human operator."), 
       Units ( "MilliSeconds" )]
   uint64 UnloadTime;

      [Description (
          "For a MediaAccessDevice that supports removable Media, the "
          "number of times that Media have been mounted for data "
          "transfer or to clean the Device. For Devices accessing "
          "nonremovable Media, such as hard disks, this property is "
          "not applicable and should be set to 0."), 
       Counter]
   uint64 MountCount;

      [Description (
          "For a MediaAccessDevice that supports removable Media, the "
          "most recent date and time that Media was mounted on the "
          "Device. For Devices accessing nonremovable Media, such as "
          "hard disks, this property has no meaning and is not "
          "applicable.")]
   datetime TimeOfLastMount;

      [Description (
          "For a MediaAccessDevice that supports removable Media, the "
          "total time (in seconds) that Media have been mounted for "
          "data transfer or to clean the Device. For Devices accessing "
          "nonremovable Media, such as hard disks, this property is "
          "not applicable and should be set to 0.")]
   uint64 TotalMountTime;

      [Description (
          "Defines 'Units' relative to its use in the property, "
          "MaxUnitsBeforeCleaning. This describes the criteria used to "
          "determine when the MediaAccessDevice should be cleaned."), 
       ModelCorrespondence { 
          "CIM_MediaAccessDevice.MaxUnitsBeforeCleaning",
          "CIM_MediaAccessDevice.UnitsUsed" }]
   string UnitsDescription;

      [Description (
          "An unsigned integer indicating the maximum 'units' that can "
          "be used, with respect to the AccessDevice, before the "
          "Device should be cleaned. The property, UnitsDescription, "
          "defines how 'units' should be interpreted."), 
       ModelCorrespondence { "CIM_MediaAccessDevice.UnitsDescription" }]
   uint64 MaxUnitsBeforeCleaning;

      [Description (
          "An unsigned integer indicating the currently used 'units' "
          "of the AccessDevice, helpful to describe when the Device "
          "may require cleaning. The property, UnitsDescription, "
          "defines how 'units' should be interpreted."), 
       Gauge, 
       ModelCorrespondence { "CIM_MediaAccessDevice.UnitsDescription",
          "CIM_MediaAccessDevice.MaxUnitsBeforeCleaning" }]
   uint64 UnitsUsed;

      [Description (
          "Method to lock and unlock the media in a removeable Access "
          "Device. The method takes one parameter as input - a boolean "
          "indicating whether to lock or unlock. TRUE indicates that "
          "the media should be locked in the Device, FALSE indicates "
          "that the media should be unlocked. The method returns 0 if "
          "successful, 1 if not supported, and any other value if an "
          "error occurred. The set of possible return codes should be "
          "specified in a ValueMap qualifier on the method. The "
          "strings to which the ValueMap contents are 'translated' "
          "should be specified as a Values array qualifier on the "
          "method.")]
   uint32 LockMedia ( 
         [IN, Description (
             "If TRUE, lock the media. If FALSE release the media.")]
      boolean Lock); 
};


// ===================================================================
// DiskDrive
// ===================================================================
   [Version ( "2.6.0" ), Description (
       "Capabilities and managment of a DiskDrive, a subtype of "
       "MediaAccessDevice.")]
class CIM_DiskDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// DisketteDrive
// ===================================================================
   [Version ( "2.6.0" ), Description (
       "Capabilities and managment of a DisketteDrive, a subtype of "
       "MediaAccessDevice.")]
class CIM_DisketteDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// CDROMDrive
// ===================================================================
   [Version ( "2.6.0" ), Description (
       "Capabilities and managment of a CDROMDrive, a subtype of "
       "MediaAccessDevice.")]
class CIM_CDROMDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// DVDDrive
// ===================================================================
   [Version ( "2.6.0" ), Description (
       "Capabilities and management of a DVDDrive, a subtype of "
       "MediaAccessDevice.")]
class CIM_DVDDrive : CIM_MediaAccessDevice {

      [Description (
          "The CD and DVD formats that are supported by this Device. "
          "For example, the Drive may support \"CD-ROM\" and "
          "\"DVD-RAM\". In this case, the values 16 and 24 would be "
          "written to the array. This property's values align with "
          "those defined in PhysicalMedia.MediaType."), 
       ValueMap { "0", "1", "16", "17", "18", "19", "22", "23", "24",
          "25", "26", "27", "33", "34", "35", "36", "37", "38", "39",
          "40", "41", "42" }, 
       Values { "Unknown", "Other", "CD-ROM", "CD-ROM/XA", "CD-I",
          "CD Recordable", "DVD", "DVD-RW+", "DVD-RAM", "DVD-ROM",
          "DVD-Video", "Divx", "CD-RW", "CD-DA", "CD+",
          "DVD Recordable", "DVD-RW", "DVD-Audio", "DVD-5", "DVD-9",
          "DVD-10", "DVD-18" }, 
       ModelCorrespondence { "CIM_PhysicalMedia.MediaType" }]
   uint16 FormatsSupported[];
};


// ===================================================================
// WORMDrive
// ===================================================================
   [Version ( "2.6.0" ), Description (
       "Capabilities and managment of a WORMDrive, a subtype of "
       "MediaAccessDevice.")]
class CIM_WORMDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// MagnetoOpticalDrive
// ===================================================================
   [Version ( "2.6.0" ), Description (
       "Capabilities and managment of a MagnetoOpticalDrive, a subtype "
       "of MediaAccessDevice.")]
class CIM_MagnetoOpticalDrive : CIM_MediaAccessDevice {
};


// ===================================================================
// TapeDrive
// ===================================================================
   [Version ( "2.6.0" ), Description (
       "Capabilities and managment of a TapeDrive, a subtype of "
       "MediaAccessDevice.")]
class CIM_TapeDrive : CIM_MediaAccessDevice {

      [Description (
          "EOTWarningZoneSize indicates the size, in bytes, of the "
          "area designated as 'end of tape'. Access in this area "
          "generates an 'end of tape' warning."), 
       Units ( "Bytes" )]
   uint32 EOTWarningZoneSize;

      [Description (
          "Maximum partition count for the TapeDrive.")]
   uint32 MaxPartitionCount;

      [Description (
          "Padding indicates the number of bytes inserted between "
          "blocks on a tape Media."), 
       Units ( "Bytes" )]
   uint32 Padding;

      [Description (
          "Time in milliseconds to move from the most physically "
          "distant point on the tape to the beginning."), 
       Units ( "MilliSeconds" )]
   uint64 MaxRewindTime;
};


// ===================================================================
// MediaAccessStatInfo
// ===================================================================
   [Version ( "2.6.0" ), Description (
       "Statistics related to reading and writing at a specific "
       "MediaAccessDevice, or for a specific StorageExtent. Although "
       "the same class is used to represent this data, at the instance "
       "level the object holds information for the MediaAccessDevice "
       "(independent of the StorageExtent), OR for the Extent "
       "(independent of its AccessDevice). Note that this class models "
       "the same properties as MediaAccessStatData. The latter, "
       "however, uses the simplified key mechanisms of the "
       "StatisticalData class.")]
class CIM_MediaAccessStatInfo : CIM_DeviceStatisticalInformation {

      [Description (
          "The number of attempted read operations."), 
       Counter]
   uint64 ReadOperations;

      [Description (
          "The number of unrecoverable read operations."), 
       Counter]
   uint64 UnrecoverableReadOperations;

      [Description (
          "The number of attempted write operations."), 
       Counter]
   uint64 WriteOperations;

      [Description (
          "The number of unrecoverable write operations."), 
       Counter]
   uint64 UnrecoverableWriteOperations;

      [Description (
          "The number of recovered read operations."), 
       Counter]
   uint64 RecoveredReadOperations;

      [Description (
          "The number of recovered write operations."), 
       Counter]
   uint64 RecoveredWriteOperations;

      [Description (
          "The number of recovered seek operations."), 
       Counter]
   uint64 RecoveredSeekOperations;

      [Description (
          "The number of unrecoverable seek operations."), 
       Counter]
   uint64 UnrecoverableSeekOperations;

      [Description (
          "Method to reset the statistical counters. The method takes "
          "one parameter as input - an integer indicating which "
          "counter to reset. For this input parameter, 0 indicates "
          "all, 1-2 and 5 reset the 'read operation'-related counters, "
          "3-4 and 6 reset the 'write operation'-related counters, and "
          "7-8 reset the seek-related counters. The method returns 0 "
          "if successful, 1 if not supported, and any other value if "
          "an error occurred. A method is specified so that the "
          "Device's instrumentation can also reset its internal "
          "processing and counters. \n"
          "In a subclass, the set of possible return codes should be "
          "specified in a ValueMap qualifier on the method. The "
          "strings to which the ValueMap contents are 'translated' can "
          "be specified as a Values array qualifier.")]
   uint32 ResetCounter ( 
         [IN, Description (
             "The counter to reset."), 
          ValueMap { "0", "1", "2", "3", "4", "5", "6", "7", "8" }, 
          Values { "All", "Read Operations",
             "Unrecoverable Read Operations", "Write Operations",
             "Unrecoverable Write Operations",
             "Recovered Read Operations", "Recovered Write Operations",
             "Recovered Seeks", "Unrecoverable Seeks" }]
      uint16 SelectedCounter); 
};


// ===================================================================
// MediaAccessStatData
// ===================================================================
   [Version ( "2.7.0" ), Description (
       "Statistics related to reading and writing at a specific "
       "MediaAccessDevice, or for a specific StorageExtent. The same "
       "class is used to represent this data - whether for the "
       "MediaAccessDevice (independent of the StorageExtent), OR for "
       "the Extent (independent of its AccessDevice). The element "
       "whose statistics are described is associated using the "
       "relationship, ElementStatisticalData. Note that this class "
       "models the same properties as MediaAccessStatInfo. This class, "
       "however, uses the simplified key mechanisms of its superclass, "
       "StatisticalData.")]
class CIM_MediaAccessStatData : CIM_StatisticalData {

      [Description (
          "The number of attempted read operations."), 
       Counter]
   uint64 ReadOperations;

      [Description (
          "The number of unrecoverable read operations."), 
       Counter]
   uint64 UnrecoverableReadOperations;

      [Description (
          "The number of attempted write operations."), 
       Counter]
   uint64 WriteOperations;

      [Description (
          "The number of unrecoverable write operations."), 
       Counter]
   uint64 UnrecoverableWriteOperations;

      [Description (
          "The number of recovered read operations."), 
       Counter]
   uint64 RecoveredReadOperations;

      [Description (
          "The number of recovered write operations."), 
       Counter]
   uint64 RecoveredWriteOperations;

      [Description (
          "The number of recovered seek operations."), 
       Counter]
   uint64 RecoveredSeekOperations;

      [Description (
          "The number of unrecoverable seek operations."), 
       Counter]
   uint64 UnrecoverableSeekOperations;
};

// ===================================================================
// SCSITargetPortGroup
// ===================================================================
   [Experimental, Version ( "2.8.1000" ), Description (
       "A class derived from SystemSpecificCollection that models SCSI "
       "Target Port Groups. SCSITargetPortGroup is part of the model "
       "for devices with asymmetric access to logical units - access "
       "is optimized for a subset of target ports. SCSITargetPortGroup "
       "is aggregated to SCSIProtocolEndpoints that expose a common "
       "ValueMap { 2, 3, 4, 5, 6 }, Values { Active/Optimized, "
       "Active/Non-optimized, StandBy, Unavailable, Transitioning }, "
       "access state for a set of associated logical Units (modeled by "
       "various subclasses of LogicalDevice). SCSITargetPortGroups "
       "only apply to target devices with asymmetric multipath access "
       "and not to devices with symmetric (or single path) access.")]
class CIM_SCSITargetPortGroup : CIM_SystemSpecificCollection {

      [Description (
          "Access to all associated logical units through all "
          "aggregated ports share this access state. Access to the "
          "Logical Units through other ports is specified by the "
          "access state of those port's target port group."), 
       ValueMap { "2", "3", "4", "5" }, 
       Values { "Active/Optimized", "Active/Non-optimized", "StandBy",
          "Unavailable" }, 
       MappingStrings { "SPC.INCITS-T10 |Asymmetric Access State",
          "MP_API.SNIA|MP_ACCESS_STATE_TYPE" }]
   uint16 AccessState;

      [Description (
          "True indicates that the underlying implementation provides "
          "an interface allowing the administrator to reassign logical "
          "units to target port groups."), 
       MappingStrings { 
          "MP_API.SNIA|MP_TARGET_PORT_PROPERTIES|supportsLuAssignment" 
          }]
   boolean supportsLuAssignment;

};

// ===================================================================
// SCSIMultipathConfigurationCapabilities
// ===================================================================

   [Experimental, Version ( "2.8.1000" ), Description (
       "A class derived from CIM_Capabilities that models the "
       "capabilities of a multipath driver. Note that 'path' in this "
       "context refers to end-to-end device paths (for example, SCSI "
       "initiator/target) with no understanding of edge paths between "
       "interconnect elements such as switches. Load balancing only "
       "applies to symmetric multipath devices or to the ports in "
       "SCSITargetPortGroups in active access state. \n"
       "A driver may support different algorithms for load balancing. "
       "A few common algorithms are listed. Algorithms for specific "
       "device models and software vendor specific algorithms are also "
       "accommodated.")]
class CIM_SCSIMultipathConfigurationCapabilities : CIM_Capabilities {

      [Description (
          "The load balance types supported by the driver for all "
          "logical units on a target device. If 'Product Specified' is "
          "included, one or more instances of CIM_Product must be "
          "aggregated to the capabilities instance via "
          "ConcreteComponent. Each Product instance provides the SCSI "
          "Vendor, Product, and Revision ID of a supported product."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6", "7" }, 
       Values { "Unknown", "Other", "No Load Balancing", "Round Robin",
          "Least Blocks", "Least IO", "LBA Region",
       "Product Specific" }, 
       MappingStrings { "MP_API.SNIA|MP_LOAD_BALANCE_TYPE" },
       ArrayType ( "Indexed" ), 
       ModelCorrespondence { 
          "CIM_SCSIMultipathConfigurationCapabilities." 
          "OtherSupportedLoadBalanceAlgorithmNames",
          "CIM_SCSIMultipathConfigurationCapabilities." 
          "OtherSupportedLoadBalanceVendorNames" }]
   uint16 SupportedLoadBalanceTypes[];

      [Description (
          "When the corresponding array entry in "
          "SupportedLoadBalanceTypes[] is 'Other', this entry provides "
          "a string describing the load balancing algorithm. When the "
          "corresponding array entry in SupportedLoadBalanceTypes[] is "
          "'Product Specific', this entry provides a string specifying "
          "the SCSI vendor/product/revision and must be formatted as "
          "exactly 28 ASCII characters - 8 for vendor, 16 for product, "
          "and 4 for revision (see SCSI SPC Inquiry response)"), 
       MappingStrings { "SPC.INCITS-T10 |Standard Inquiry Response",
          "MP_API.SNIA|MP_LOAD_BALANCE_TYPE",
          "MP_API.SNIA|MP_DEVICE_PRODUCT_PROPERTIES" },
          ArrayType ( "Indexed" ), 
       ModelCorrespondence { 
          "CIM_SCSIMultipathConfigurationCapabilities." 
          "SupportedLoadBalanceTypes",
          "CIM_SCSIMultipathConfigurationCapabilities." 
          "OtherSupportedLoadBalanceVendorNames" }]
   string OtherSupportedLoadBalanceAlgorithmNames[];

      [Description (
          "When the corresponding array entry in "
          "SupportedLoadBalanceTypes[] is 'Other', this entry provides "
          "a string describing the vendor associated with the load "
          "balancing algorithm."), 
       MappingStrings { "MP_API.SNIA|MP_LOAD_BALANCE_TYPE" },
       ArrayType ( "Indexed" ), 
       ModelCorrespondence { 
          "CIM_SCSIMultipathConfigurationCapabilities." 
          "SupportedLoadBalanceTypes",
          "CIM_SCSIMultipathConfigurationCapabilities." 
          "OtherSupportedLoadBalanceAlgorithmNames" }]
   string OtherSupportedLoadBalanceVendorNames[];

      [Description (
          "The capability of the driver to support the SetTPGAccess "
          "method. True if the implementation supports activating "
          "target port groups."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|canSetTPGAccess" }, 
       ModelCorrespondence { 
          "CIM_SCSIPathConfigurationService.SetTPGAccess" }]
   boolean CanSetTPGAccess = false;

      [Description (
          "The capability of the driver to support the SetOverridePath "
          "and CancelOverridePaths methods. True if the implementation "
          "supports path overrides."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|canOverridePaths" }, 
       ModelCorrespondence { 
          "CIM_SCSIPathConfigurationService.SetOverridePath" }]
   boolean CanOverridePaths = false;

      [Description (
          "False if the MP drivers assure only a single device file "
          "name (e.g. /dev/dsk/...) exists for each MP device. True if "
          "the implementation exposes (or leaves exposed) device files "
          "for the individual paths encapsulated by the multipath "
          "device file. This is typically true for MP drivers that sit "
          "near the top of the driver stack and false for transport "
          "drivers at the bottom of the stack."), 
       MappingStrings { "MP_API.SNIA|Plugin " 
          "Properties|exposesPathDeviceFiles" }]
   boolean ExposesPathDeviceFiles;

      [Description (
          "A string representing the primary file names the driver "
          "uses for multipath logical units, if those filenames do not "
          "match the names in Logical Unit osDeviceName as documented "
          "in Appendix A of the SNIA MP API specification. The name is "
          "expressing in the following format: \n"
          "'*' represents one or more alphanumeric characters \n"
          "'#' represents a string of consecutive digits \n"
          "'%' represents a string of hexadecimal digits \n"
          "backslash is an escape character for literal presentation "
          "of *, #, or %. Any other character is interpreted "
          "literally. For example, '/dev/vx/dmp/*'. If the multipath "
          "driver creates multipath logical unit device file names in "
          "the same namespace as the OS then this property should be "
          "left null."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|deviceNameFilespace" }]
   string DeviceNameFilespace;

      [Description (
          "True if the only supported device types are those described "
          "in aggregated CIM_Product instances as described in the "
          "description of SupportedLoadBalanceTypes."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|deviceNameFilespace" }, 
       ModelCorrespondence { 
          "CIM_SCSIMultipathConfigurationCapabilities." 
          "SupportedLoadBalanceTypes" }]
   boolean OnlySupportsSpecifidProducts = false;

      [Description (
          "Describes the range of administer settable path weights "
          "supported by the driver. A driver with no path preference "
          "capabilities should set this property to zero. A driver "
          "with the ability to enable/disable paths should set this "
          "property to 1. Drivers with more weight settings can set "
          "the property appropriately."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|maximumWeight" }]
   uint32 MaximumWeight;

      [Description (
          "The maximum polling rate (in seconds) supported by the "
          "driver. A value of zero indicates the driver/plugin does "
          "not support polling. This maximum applies to both "
          "BadPathPollingRate and InactivePathPollingRate."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|pollingRateMax" }]
   uint32 PollingRateMax;

      [Description (
          "The minimum polling rate (in seconds) supported by the "
          "driver. This minimum applies to both BadPathPollingRate and "
          "InactivePathPollingRate."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|pollingRateMin" }]
   uint32 PollingRateMin;

      [Description (
          "A Boolean indicating whether the driver will automatically "
          "revert back to preferred (i.e higher weight) paths when "
          "they return to service."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|autoFailbackSupported" }]
   boolean AutoFailbackSupported;

      [Write, Description (
          "A Boolean indicating whether auto failback is currently "
          "enabled. Only valid when autoFailbackSupported is true."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|autoFailbackEnabled" }]
   boolean AutoFailbackEnabled;

      [Write, Description (
          "The rate in seconds between polling I/Os to paths that are "
          "marked unavailable due to hardware errors. Only valid when "
          "pollingRateMax is greater than 0 and canAutoFailback are "
          "true."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|badPathPollingRate" }]
   uint32 BadPathPollingRate;

      [Write, Description (
          "The rate in seconds between polling I/Os to paths that are "
          "not is use due to administrative settings (pathWeight or "
          "manual overrides). Only valid when pollingRateMax is "
          "greater than zero."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|inactivePathPollingRate" }]
   uint32 InactivePathPollingRate;

      [Write, Description (
          "The load balance types supported by the driver if not "
          "overridden by an administrative action."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6" }, 
       Values { "Unknown", "Other", "No Load Balancing", "Round Robin",
          "Least Blocks", "Least IO", "Product Specific" }, 
       MappingStrings { 
          "MP_API.SNIA|MP_PLUGIN_PROPERTIES|defaultLoadBalanceType" }]
   uint16 DefaultLoadBalanceType;

};



// ===================================================================
// SCSIInitiatorTargetLogicalUnitPath
// ===================================================================

   [Association, Experimental, Version ( "2.8.1000" ), Description (
       "An association that models a host driver path to a SCSI "
       "logical unit. Each permutation of initiator and target "
       "ProtocolEndpoints and logical units is considered a separate "
       "path. This class describes end-to-end path behavior such as "
       "properties and operations commonly used in multipath "
       "management.")]
class CIM_SCSIInitiatorTargetLogicalUnitPath {

      [Key, Description (
          "An initiator endpoint.")]
   CIM_SCSIProtocolEndpoint REF Initiator;

      [Key, Description (
          "A target endpoint.")]
   CIM_SCSIProtocolEndpoint REF Target;

      [Key, Description (
          "A subclass of LogicalDevice representing a SCSI Logical "
          "Unit (such as StorageVolume or TapeDrive).")]
   CIM_LogicalDevice REF LogicalUnit;

      [Description (
          "The OS Device Name for this path. Only applicable if the "
          "ExposedPathDeviceFiles property is true in the instance of "
          "SCSIMultipathConfigurationCapabilities associated with the "
          "LogicalDevice/RedundancySet this instance is a member of."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PATH_LOGICAL_UNIT_PROPERTIES|deviceFileName" 
          }]
   string OSDeviceName;

      [Write, Description (
          "A value assigned by an administrator specifying a "
          "preference to assign to a path. The drivers will actively "
          "use all available paths with the highest weight. This "
          "allows an administrator to assign a subset of available "
          "paths for load balanced access and reserve the others as "
          "backup paths. For symmetric access devices, all paths are "
          "considered 'available'. For asymmetric access devices, all "
          "paths in active target port groups are considered "
          "available."), 
       MappingStrings { 
          "MP_API.SNIA|MP_PATH_LOGICAL_UNIT_PROPERTIES|weight" }]
   uint32 AdministrativeWeight;

      [Write, Description (
          "The state of this path. Values are defined as follows: \n"
          "Unknown - the path is unavailable,but the cause is not "
          "known. \n"
          "Active - The path is okay and active. \n"
          "Passive - The path is okay, but is associated with a target "
          "port of target port group in standby access state. Only "
          "applies to devices with asymmetric access. \n"
          "Disabled - The path is disabled by administrative request "
          "(DisablePathLU). \n"
          "Path Error - The path is unusable due to an error on this "
          "path and no SCSI status was received. \n"
          "Logical Unit Error - A SCSI status was received for an I/O "
          "through this path indicating a logical unit error. \n"
          "Reserved - The path is unavailable due to a SCSI "
          "reservation. \n"
          "Removed - The path is unavailable because the OS or drivers "
          "marked the pathunusable. \n"
          "Transitioning - the path is transitioning between two valid "
          "states. \n"
          "The only valid values a client can specify are Disabled and "
          "Active. All other states are determined by the underlying "
          "implementation; attempts to set them should be given an "
          "error response."), 
       ValueMap { "0", "2", "3", "4", "5", "6", "7", "8", "9" }, 
       Values { "Unknown", "Active", "Passive", "Disabled",
          "Path Error", "Logical Unit Error", "Reserved", "Removed",
          "Transitioning" }, 
       MappingStrings { 
          "MP_API.SNIA|MP_PATH_LOGICAL_UNIT_PROPERTIES|pathState" }]
   uint32 State;

      [Description (
          "AdministrativeOverride allows an administrator to select a "
          "single path, force all I/O to this path, and disables load "
          "balancing. The steady-state value is 'No override in "
          "effect'. When an administrator sets an override for a "
          "particular path, that path's AdministrativeOverride is set "
          "to 'Overridding' and all other paths to same logical unit "
          "are assigned a value of 'Overridden'. This property is "
          "changed using the OverridePath method in "
          "SCSIPathConfigurationService."), 
       ValueMap { "2", "3", "4" }, 
       Values { "Overriding", "Overridden", "No override in effect" }, 
       MappingStrings { 
          "MP_API.SNIA|MP_MULTIPATH_LOGICAL_UNIT_PROPERTIES|overridePath" 
          }, 
       ModelCorrespondence { 
          "CIM_SCSIPathConfigurationService.SetOverridePath" }]
   uint16 AdministrativeOverride;
};

// ===================================================================
// SCSIPathConfigurationService
// ===================================================================

   [Experimental, Version ( "2.8.1000" ), Description (
       "A class derived from CIM_Service providing methods related to "
       "management of multiple paths to SCSI devices.")]
class CIM_SCSIPathConfigurationService : CIM_Service {

      [Description (
          "This method requests that the target change the access "
          "states of the requested SCSITargetPortGroups. This will "
          "have the effect of doing a failover or failback operation."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "..", "4096", "4097",
          "4098", "4099", "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unknown", "Timeout",
          "Failed", "Invalid Parameter", "DMTF Reserved",
          "Unsupported AccessState", "Invalid SCSITargetPortGroup",
          "Unsupported AccessState combination",
          "Unsupported SCSITargetPortGroup combination",
          "Method Reserved", "Vendor Specific" }]
   uint32 SetTPGAccess ( 
         [IN, Description (
             "A reference to an instances of a subclass of "
             "CIM_LogicalDevice representing the SCSI logical unit "
             "where the command will be sent.")]
      CIM_LogicalDevice REF LogicalUnit, 
         [IN, Description (
             "Array of references to instances of SCSITargetPortGroup. "
             "All the referenced TargetPortGroup instances must be "
             "part of the same target device."), 
          ArrayType ( "Indexed" ), 
          ModelCorrespondence { "CIM_SCSITargetPortGroup" }]
      CIM_SCSITargetPortGroup REF TargetPortGroups[], 
         [IN, Description (
             "An array of desired access states. Each access state in "
             "this array is the desired access state for the "
             "SCSITargetPortGroup in the corresponding entry in the "
             "TargetPortGroups parameter. \n"
             "\n"
             "The Active value is not part of the SCSI Specification; "
             "it is a convenience for clients that are not sure "
             "whether to specify Active/Optimized of "
             "Active/Non-optimized. The instrumentation selects a "
             "value based on historic information, knowledge of the "
             "target configuration, or trial and error. \n"
             "\n"
             "Note that SCSITargetPortGroup.AccessState includes the "
             "value 'Transitioning' that is excluded here - a caller "
             "cannot request transitioning, though it can be reported "
             "by a target device."), 
          ValueMap { "2", "3", "4", "5", "6" }, 
          Values { "Active/Optimized", "Active/Non-optimized",
             "StandBy", "Unavailable", "Active" },
             ArrayType ( "Indexed" ), 
          ModelCorrespondence { "CIM_SCSITargetPortGroup.AccessState" }]
      uint16 AccessStates[] ); 

      [Description (
          "This method requests that the target change the load "
          "balance algorithm for the referenced LogicalDevice "
          "instance."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "..", "4096", "4097",
          "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unknown", "Timeout",
          "Failed", "Invalid Parameter", "DMTF Reserved",
          "Unsupported LogicalDevice", "Invalid LoadBalanceType",
          "Method Reserved", "Vendor Specific" }]
   uint32 SetLoadBalanceAlgorithm ( 
         [IN, Description (
             "A reference to the LogicalDevice subclass instance with "
             "an LogicalIdentity to the load balance RedundancySet. If "
             "SCSIMultipathConfigurationCapabilities. "
             "CanLoadBalanceLUsIndependently is true, just the "
             "referenced logical unit is modified. Otherwise, all "
             "logical units sharing the target are modified.")]
      CIM_LogicalDevice REF LogicalDevice,
      
         [IN, Description (
             "The desired load balance algorithm."), 
          ValueMap { "0", "1", "2", "3", "4", "5", "6" }, 
          Values { "Unknown", "Other", "No Load Balancing",
             "Round Robin", "Least Blocks", "Least IO",
             "Product Specific" }]
      uint16 LoadBalanceAlgorithm,
      
         [IN, Description (
             "When LoadBalanceAlgorithm is 'Other', this parameter "
             "specifies a description of the load balancing algorithm. "
             "When LoadBalanceAlgorithm is 'Product Specific', this "
             "property provides a string specifying the "
             "vendor/product/version of the ManagedElement.")]
      string OtherLoadBalanceAlgorithmDescription ); 


      [Description (
          "This method allows an administrator to assign a logical "
          "unit to a target port group. At any time, each LU will "
          "typically be associated with two target port groups, one in "
          "active state and one in standby state. The result of this "
          "method will be that the LU associations change to a pair of "
          "target port groups. Only valid if the target device "
          "supports asymmetric access state and "
          "SCSIMultipathConfigurationCapabilities SupportsLuAssignment "
          "is set."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unknown", "Timeout",
          "Failed", "Invalid Parameter", "DMTF Reserved",
          "Vendor Specific" }]
   uint32 AssignLogicalUnitToPortGroup ( 
         [IN, Description (
             "A reference to a target port group. The Target Port "
             "Group should be in an active state.")]
      CIM_SCSITargetPortGroup REF TargetPortGroup ); 

      [Description (
          "This method allows an administrator to temporarily disable "
          "load balancing for a specific logical unit. The path "
          "specified as a parameter will have its "
          "AdministrativeOverride property set to 'Overriding' and all "
          "I/O to the logical unit will be directed to this path. All "
          "other paths to this logical unit will have "
          "AdministrativeOverride set to 'Overridden'."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unknown", "Timeout",
          "Failed", "Invalid Parameter", "DMTF Reserved",
          "Vendor Specific" }]
   uint32 SetOverridePath ( 
         [IN, Description (
             "A reference to a SCSIInitiatorTargetLogicalUnitPath.")]
      CIM_SCSIInitiatorTargetLogicalUnitPath REF Path ); 

      [Description (
          "This method clears an override path as set in "
          "SetOverridePath and load balancing is enabled. All paths to "
          "the logical unit specified as a parameter will have "
          "AdministrativeOverride property set to 'No override in "
          "effect'."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "..", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unknown", "Timeout",
          "Failed", "Invalid Parameter", "DMTF Reserved",
          "Vendor Specific" }]
   uint32 CancelOverridePath ( 
         [IN, Description (
             "A reference to a SCSIInitiatorTargetLogicalUnitPath.")]
      CIM_LogicalDevice REF LogicalUnit ); 

};


// ===================================================================
// end of file
// ===================================================================
