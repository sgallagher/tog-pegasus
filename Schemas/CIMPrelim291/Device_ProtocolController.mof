// ===================================================================
// Title:  Device Protocol Controller
// $State: Exp $
// $Date: 2005/02/24 20:05:58 $
// $Source: /cvs/MSB/pegasus/Schemas/CIMPrelim291/Attic/Device_ProtocolController.mof,v $
// $Revision: 1.1 $
// ===================================================================
//#pragma inLine ("Includes/copyright.inc")
// Copyright 1998-2005 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.
// DMTF is a not-for-profit association of industry members dedicated
// to promoting enterprise and systems management and interoperability.
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members,
// provided that correct attribution is given.
// As DMTF specifications may be revised from time to time,
// the particular version and release date should always be noted.
// 
// Implementation of certain elements of this standard or proposed
// standard may be subject to third party patent rights, including
// provisional patent rights (herein "patent rights"). DMTF makes
// no representations to users of the standard as to the existence
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or
// claimants, nor for any incomplete or inaccurate identification or
// disclosure of such rights, owners or claimants. DMTF shall have no
// liability to any party, in any manner or circumstance, under any
// legal theory whatsoever, for failure to recognize, disclose, or
// identify any such third party patent rights, or for such party's
// reliance on the standard or incorporation thereof in its product,
// protocols or testing procedures. DMTF shall have no liability to
// any party implementing such standard, whether such implementation
// is foreseeable or not, nor to any patent owner or claimant, and shall
// have no liability or responsibility for costs or losses incurred if
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the
// standard from any and all claims of infringement by a patent owner
// for such implementations.
// 
// For information about patents held by third-parties which have
// notified the DMTF that, in their opinion, such patent may relate to
// or impact implementations of DMTF standards, visit
// http://www.dmtf.org/about/policies/disclosures.php.
//#pragma inLine
// ===================================================================
// Description: The Device Model extends the management concepts that
//              are related to LogicalDevices. This file defines
//              the concepts and classes for Protocol Controllers.
// 
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined
//              by other working groups, are omitted.
// ==================================================================
// Change Log for v2.9 Preliminary Company Review
// CR1448 - Add a capability property and return value to ExposePaths
//          method
// CR1429 - Clarify description and values of
//          ProtocolControllerForDevice.AccessState
// 
// Change Log for v2.9 preliminary
// CR1202 - Add iSCSI related values to
//    CIM_ProtocolControllerMaskingCapabilities.ValidHardwareIdTypes[]
// CR1294 - Add NameFormat to ScsiProtocolController.
// CR1350 - New method & updates for LUN Masking and Mapping
// CR1335 - Add DeviceAccess property to ProtocolControllerForUnit and
//          ProtocolControllerAccessesUnit
// CR1351 - Add iSCSI names to Values/ValueMap list in
//          ProtocolControllerMaskingCapabilities
// 
// Change Log for v2.8 Final
// CR1202 - Experimental to Final for Device
// CR1201 - Fix use of Privilege/Identity in
// CreateProtocolControllerWithPorts()
// CR1223 - Fix ambiguity in ProtocolControllerMaskingCapabilities
// 
// Change Log for v2.8 Preliminary
// CR1015 - Initial ProtocolController definition
// CR1007 - Addition of ControllerConfigurationService and
//          StorageMaskingService
// CR1040 - Improves CreateProtocolController by allowing
//          atomic creation with permissions.
// CR1055 - Remove ConnectionRole from ProtocolController
//          Add UsageRestriction to NetworkPort
// CR1082 - Change StorageMaskingCapabilities to be
//          ProtocolControllerMaskingCapabilities
// CR1108 - Change CreatePortProtocolController to
//          CreateProtocolControllerWithPorts
// 
// ==================================================================

#pragma locale ("en_US")


// ===================================================================
// ProtocolController
// ===================================================================
   [Abstract, Version ( "2.8.0" ), Description (
       "ProtocolController is a superclass for grouping controllers "
       "that are used to control the operation and function of "
       "sophisticated devices that instantiate a protocol such as "
       "SCSI. Simpler 'bus' and device controllers are modeled using "
       "the CIM_Controller class.")]
class CIM_ProtocolController : CIM_LogicalDevice {

      [Description (
          "Maximum number of Units that can be controlled by or "
          "accessed through this ProtocolController.")]
   uint32 MaxUnitsControlled;
};

// ===================================================================
// SCSIProtocolController
// ===================================================================
   [Version ( "2.8.1000" ), Description (
       "SCSIProtocolController is a type of ProtocolController, "
       "managing a SCSI interface.")]
class CIM_SCSIProtocolController : CIM_ProtocolController {

      [Experimental, Description (
          "The NameFormat property identifies how the Name of the "
          "SCSIProtocolController is selected. \n"
          "For Fibre Channel, the NameFormat is 'FC Port WWN'. \n"
          "For iSCSI, Name can use any of the 3 iSCSI formats (iqn, "
          "eui, naa) which include the iSCSI format as as a prefix in "
          "the name, so they are not ambiguous."), 
       ValueMap { "0", "1", "2", "3" }, 
       Values { "Unknown", "Other", "FC Port WWN", "iSCSI Name" }, 
       ModelCorrespondence { "CIM_SCSIProtocolController.Name",
          "CIM_SCSIProtocolController.OtherNameFormat" }]
   uint16 NameFormat;

      [Experimental, Description (
          "A string describing how the ProtocolController is "
          "identified when the NameFormat is \"Other\"."), 
       ModelCorrespondence { "CIM_SCSIProtocolController.Name",
          "CIM_SCSIProtocolController.NameFormat" }]
   string OtherNameFormat;
};

// ===================================================================
// ProtocolControllerForDevice
// ===================================================================
   [Association, Abstract, Version ( "2.8.1000" ), Description (
       "This association indicates a subclass of LogicalDevice (for "
       "example a Storage Volume) is connected through a specific "
       "ProtocolController. In many situations (for example storage "
       "LUN masking), there may be many of these associations used to "
       "relate to different objects. Therefore subclasses have been "
       "defined to optimize enumeration of the associations.")]
class CIM_ProtocolControllerForDevice : CIM_Dependency {

      [Override ( "Antecedent" ), Description (
          "The ProtocolController.")]
   CIM_ProtocolController REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The controlled Device.")]
   CIM_LogicalDevice REF Dependent;

      [Description (
          "Address of the associated Device in the context of the "
          "Antecedent Controller.")]
   string DeviceNumber;

      [Description (
          "This property describes the priority given to accesses of "
          "the device through this Controller. The highest priority "
          "path will have the lowest value for this parameter.")]
   uint16 AccessPriority;

      [Description (
          "The AccessState property describes the accessibility of the "
          "LogicalDevice through the ProtocolController. \n"
          "Unknown (0) indicates the instrumentation does not know "
          "whether access is or is not functioning. \n"
          "Active (2) indicates normal access. \n"
          "Inactive (3) indicates the instrumentation knows this path "
          "is not active, and one of the other values (below) does not "
          "apply. \n"
          "Replication in Progress (4) indicates that the path is "
          "temporarily inactive due to a replication activity. \n"
          "Mapping Inconsistency (5) indicates the instrumentation has "
          "detected that this path is inactive due to an inconsistency "
          "in the DeviceNumber/DeviceAccess configuration."), 
       ValueMap { "0", "2", "3", "4", "5" }, 
       Values { "Unknown", "Active", "Inactive",
          "Replication In Progress", "Mapping Inconsistency" }]
   uint16 AccessState;

};

// ===================================================================
// AssociatedProtocolController
// ===================================================================
   [Association, Version ( "2.8.0" ), Description (
       "This association is used to define a hierarchy relationship "
       "between ProtocolControllers. This subclass is provided so that "
       "an enumeration of related ProtocolControllers can be performed "
       "without retrieving any connected StorageVolumes, "
       "MediaAccessDevices or LogicalPorts.")]
class CIM_AssociatedProtocolController : CIM_ProtocolControllerForDevice {

      [Override ( "Antecedent" ), Description (
          "The 'upstream', Antecedent ProtocolController.")]
   CIM_ProtocolController REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The 'downstream' Dependent ProtocolController.")]
   CIM_ProtocolController REF Dependent;
};

// ===================================================================
// ProtocolControllerForPort
// ===================================================================
   [Association, Version ( "2.8.0" ), Description (
       "This association is used to define a relationship between a "
       "ProtocolController and a LogicalPort. This subclass is "
       "provided so that an enumeration of related controllers and "
       "ports can be performed without retrieving any other "
       "controllers or connected units.")]
class CIM_ProtocolControllerForPort : CIM_ProtocolControllerForDevice {

      [Override ( "Antecedent" ), Description (
          "The ProtocolController.")]
   CIM_ProtocolController REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The LogicalPort 'behind' the ProtocolController.")]
   CIM_LogicalPort REF Dependent;
};

// ===================================================================
// ProtocolControllerForUnit
// ===================================================================
   [Association, Version ( "2.8.0" ), Description (
       "This association is used to define a relationship between a "
       "ProtocolController and an exposed Logical Unit (for example a "
       "Storage Volume or a MediaAccessDevice such as a tape drive). "
       "An example of the use of this association is SCSI, where it "
       "link the target controller and Logical Units. This subclass is "
       "provided so that an enumeration of related controllers and "
       "units can be performed without retrieving any connected ports "
       "or other controllers.")]
class CIM_ProtocolControllerForUnit : CIM_ProtocolControllerForDevice {

      [Override ( "Antecedent" ), Description (
          "The ProtocolController.")]
   CIM_ProtocolController REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The logical unit (eg StorageVolume) 'behind' the "
          "ProtocolController.")]
   CIM_LogicalDevice REF Dependent;

      [Experimental, Description (
          "The access rights granted to the referenced logical unit as "
          "exposed through referenced ProtocolController. The 'No "
          "Access' value is used in implementations where the "
          "DeviceNumber is reserved, but no access is granted. \n"
          "If the instrumentation exposes PrivilegeManagementService, "
          "this property MUST be synchronized with the Activities "
          "property of any Privilege instances associated with "
          "StorageHardwareIDs associated to the referenced "
          "ProtocolController and the referenced LogicalDevice. In "
          "particular, when this property is 'Read Write', "
          "Privilege.Activities MUST include entries for 'Read' and "
          "'Write'. When this property is 'Read-Only', "
          "Privilege.Activities MUST include an entry for 'Read'. The "
          "corresponding entries for Privilege.ActivityQualifiers MUST "
          "be 'CDB=*' and the corresponding entries for "
          "Privilege.QualifierFormat MUST be 'SCSI Command'."), 
       ValueMap { "0", "2", "3", "4", "5..15999", "16000.." }, 
       Values { "Unknown", "Read Write", "Read-Only", "No Access",
          "DMTF Reserved", "Vendor Reserved" }]
   uint16 DeviceAccess;
};

// ===================================================================
// ProtocolControllerAccessesUnit
// ===================================================================
   [Association, Version ( "2.8.0" ), Description (
       "This association is used to define a relationship between a "
       "protocol controllers and a Logical Unit (for example a Storage "
       "Volume or Media Access Device) controlled by the controller. "
       "This association is used instead of ProtocolControllerForUnit "
       "to indicate a 'controlled through' relationship rather than a "
       "'controlled by' one. An example is SCSI where this association "
       "is used to indicate a target/initiator relationship.")]
class CIM_ProtocolControllerAccessesUnit : CIM_ProtocolControllerForDevice {

      [Override ( "Antecedent" ), Description (
          "The protocol controller.")]
   CIM_ProtocolController REF Antecedent;

      [Override ( "Dependent" ), Description (
          "The logical unit (eg StorageVolume).")]
   CIM_LogicalDevice REF Dependent;

      [Description (
          "The number of the dependent's target protocol controller. "
          "As an example, in SCSI this is the Target ID.")]
   string TargetControllerNumber;

      [Experimental, Description (
          "The access rights granted to the referenced logical unit as "
          "exposed through referenced ProtocolController. The 'No "
          "Access' value is used in implementations where the "
          "DeviceNumber is reserved, but no access is granted. \n"
          "If the instrumentation exposes PrivilegeManagementService, "
          "this property MUST be synchronized with the Activities "
          "property of any Privilege instances associated with "
          "StorageHardwareIDs associated to the referenced "
          "ProtocolController and the referenced LogicalDevice. In "
          "particular, when this property is 'Read Write', "
          "Privilege.Activities MUST include entries for 'Read' and "
          "'Write'. When this property is 'Read-Only', "
          "Privilege.Activities MUST include an entry for 'Read'. The "
          "corresponding entries for Privilege.ActivityQualifiers MUST "
          "be 'CDB=*' and the corresponding entries for "
          "Privilege.QualifierFormat MUST be 'SCSI Command'."), 
       ValueMap { "0", "2", "3", "4", "5..15999", "16000.." }, 
       Values { "Unknown", "Read Write", "Read-Only", "No Access",
          "DMTF Reserved", "Vendor Reserved" }]
   uint16 DeviceAccess;
};

// ==================================================================
//    ControllerConfigurationService
// ==================================================================
   [Version ( "2.8.1000" ), Description (
       "The ControllerConfigurationService provides methods that allow "
       "a client to manipulate LUN Masking in a storage system.")]
class CIM_ControllerConfigurationService : CIM_Service {

      [Description (
          "This method creates an appropriate subclass of "
          "ProtocolController. In addition to its role of controlling "
          "downstream devices, a ProtocolControl is used to provide a "
          "central management point for access control with respect to "
          "those devices. Certain storage system implementations "
          "across multiple vendors require permissions to be "
          "established atomically with the creation of a "
          "ProtocolController. This method provides this capability "
          "via the Privilege and Identity properties. By supplying "
          "appropriate information in those properties, this method "
          "will assure that appropriate AuthorizedTarget and "
          "AuthorizedSubject associations, (as defined in the User and "
          "Security Model), are instantiated to restrict access to the "
          "logical devices 'behind' it. \n"
          "If multiple target ports are specified in the Ports input "
          "parameter, all expose the same view (i.e., have the same "
          "unit numbers and permissions). This method does not create "
          "the port instances, but does create "
          "ProtocolControllerForPort associations between the "
          "specified ports and the new ProtocolController. The new "
          "ProtocolController is defined to be weak to the same System "
          "as the ControllerConfigurationService."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6..4095", "4096",
          "4097", "4098", "4099..32767", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unspecified Error",
          "Timeout", "Failed", "Invalid Parameter", "DMTF Reserved",
          "ID Parameter Missing or Not Unique",
          "Hardware Implementation Requires Null Ports Parameter",
          "Busy", "Method Reserved", "Vendor Specific" }]
   uint32 CreateProtocolControllerWithPorts ( 
         [IN, Description (
             "The string to be used in the ElementName of the new "
             "ProtocolController."), 
          ModelCorrespondence { "CIM_ProtocolController.ElementName" }]
      string ElementName, 
         [IN, Description (
             "Array of strings containing representations of "
             "references to instances of CIM_LogicalPort (or subclass) "
             "instances. This is the list of target ports that are "
             "associated to the ProtocolController. "
             "ProtocolControllerForPort associations are created by "
             "the instrumentation associating the new "
             "ProtocolController to these ports. If this parameter is "
             "null, then all ports in the storage system (this "
             "Service's 'scoping' System and all its ComponentCS "
             "Systems) are attached to the new ProtocolController.")]
      string Ports[], 
         [IN, Description (
             "The protocol type for the new ProtocolController."), 
          ValueMap { "0", "1", "2" }, 
          Values { "Unknown", "Other", "SCSI" }, 
          ModelCorrespondence { "CIM_SCSIProtocolController" }]
      uint16 Protocol, 
         [IN, Description (
             "Reference to a CIM_Privilege (or subclass) instance to "
             "be used as a template. If supplied, it has a 1:1 "
             "correspondence with the Identity parameter and this "
             "method will atomically create the new ProtocolController "
             "instance and related AuthorizedPrivilege, "
             "AuthorizedTarget and AuthorizedSubject instances. \n"
             "Note: if ProtocolControllerRequiresAuthorizedIdentity is "
             "true, then the Identity/Privilege pair MUST be "
             "specified. If false, then the Identity/Privilege pair "
             "MUST NOT be specified."), 
          ModelCorrespondence { "CIM_ControllerConfigurationService." 
             "CreateProtocolControllerWithPorts.Identity" }]
      CIM_Privilege REF Privilege, 
         [IN, Description (
             "Reference to a CIM_ManagedElement (or subclass) "
             "instance. This ManagedElement MUST be either a "
             "CIM_Identity, or a CIM_Collection (or subclass, eg. "
             "SystemSpecificCollection, Role, or Group) that has "
             "CIM_Identities as MemberOfCollection. If "
             "ProtocolControllerMaskingCapabilities.ProtocolControllerSupportsCollection "
             "is false, the reference MUST be to a CIM_Identity (or "
             "subclass). If present, it has a 1:1 correspondence with "
             "the Privilege property. If present, this method will "
             "atomically create the new ProtocolController instance "
             "and instantiate a missing AuthorizedSubject association "
             "between the Privilege/Identity pair; and instantiate an "
             "AuthorizedTarget association between the "
             "AuthorizedPrivilege and the new ProtocolController. \n"
             "Note: if ProtocolControllerRequiresAuthorizedIdentity is "
             "true, then at least the Identity/Privilege pair MUST be "
             "specified."), 
          ModelCorrespondence { "CIM_ControllerConfigurationService." 
             "CreateProtocolControllerWithPorts.Privilege" }]
      CIM_ManagedElement REF Identity, 
         [IN ( false ), OUT, Description (
             "A reference to the new ProtocolController that is "
             "created.")]
      CIM_ProtocolController REF ProtocolController); 

      [Description (
          "The method deletes an instance of ProtocolController and "
          "all associations in which this ProtocolController is "
          "referenced."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6..4095", "4096",
          "4097", "4098..32767", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unspecified Error",
          "Timeout", "Failed", "Invalid Parameter", "DMTF Reserved",
          "LogicalDevices Associated to Other ProtocolControllers Not " 
          "Deleted", "Busy", "Method Reserved", "Vendor Specific" }]
   uint32 DeleteProtocolController ( 
         [IN, Description (
             "The ProtocolController to be deleted.")]
      CIM_ProtocolController REF ProtocolController, 
         [IN, Description (
             "If true, the management instrumentation provider will "
             "also delete 'child' ProtocolControllers (i.e., those "
             "defined as Dependent references in instances of "
             "AssociatedProtocolController where this "
             "ProtocolController is the Antecedent reference). Also, "
             "all direct associations involving the 'child' "
             "ProtocolControllers will be removed.")]
      boolean DeleteChildrenProtocolControllers, 
         [IN, Description (
             "If true, the management instrumentation provider will "
             "also delete LogicalDevice instances associated via "
             "ProtocolControllerForUnit, to this ProtocolController "
             "and its children. (Note that 'child' controllers will "
             "only be affected if the "
             "DeleteChildrenProtocolControllers input parameter is "
             "TRUE). LogicalDevice instances are only deleted if there "
             "are NO remaining ProtocolControllerForUnit associations, "
             "to other ProtocolControllers.")]
      boolean DeleteUnits ); 

      [Description (
          "This method associates a LogicalDevice subclass "
          "(specifically a StorageVolume or MediaAccessDevice "
          "subclass) to the referenced ProtocolController. The "
          "association is persisted as an instance of "
          "ProtocolControllerForUnit. The management instrumentation "
          "provider must verify that the logical unit numbers (defined "
          "using the DeviceNumber input parameter) are unique for the "
          "ProtocolController. When the Protocol Controller is "
          "actively masking a device (i.e. is part of an "
          "AuthorizedTarget association), the provider should update "
          "the access configuration in the underlying hardware as "
          "appropriate."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6..4095", "4096",
          "4097", "4098", "4099", "4100", "4101..32767",
       "32768..65535" }, 
       Values { "Success", "Not Supported", "Unspecified Error",
          "Timeout", "Failed", "Invalid Parameter", "DMTF Reserved",
          "Invalid LogicalDevice Instance", "Device Number Conflict",
          "DeviceNumber Parameter Must Be Provided",
          "Hardware Implementation Requires Null DeviceNumber", "Busy",
          "Method Reserved", "Vendor Specific" }]
   uint32 AttachDevice ( 
         [IN, Description (
             "The ProtocolController instance.")]
      CIM_ProtocolController REF ProtocolController, 
         [IN, Description (
             "The LogicalDevice instance to attach.")]
      CIM_LogicalDevice REF Device, 
         [IN, OUT, Description (
             "The number assigned to "
             "ProtocolControllerForUnit.DeviceNumber (if supported by "
             "the hardware). Hardware support is indicated by "
             "ProtocolControllerMaskingCapabilities.ClientSelectableDeviceNumbers). "
             "If the hardware does not support setting the number, but "
             "the DeviceNumber has not been established in an existing "
             "ProtocolControllerForDevice subclass, then this "
             "parameter's value will be used. If the DeviceNumber has "
             "been established, then the current number will be "
             "reused."), 
          ModelCorrespondence { 
             "CIM_ProtocolControllerForUnit.DeviceNumber" }]
      string DeviceNumber ); 

      [Description (
          "This method removes the ProtocolControllerForDevice "
          "association subclass between the ProtocolController and a "
          "LogicalDevice, such as a StorageVolume or a "
          "MediaAccessDevice. When the ProtocolController is actively "
          "masking a device (i.e. is part of an AuthorizedTarget "
          "association, the management instrumentation provider should "
          "update the hardware access configuration when DetachDevice "
          "is called."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6..4095", "4096",
          "4097", "4098..32767", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unspecified Error",
          "Timeout", "Failed", "Invalid Parameter", "DMTF Reserved",
          "LogicalDevice Instance not Associated with Controller",
          "Busy", "Method Reserved", "Vendor Specific" }]
   uint32 DetachDevice ( 
         [IN, Description (
             "The ProtocolController instance.")]
      CIM_ProtocolController REF ProtocolController, 
         [IN, Description (
             "The LogicalDevice instance to detach.")]
      CIM_LogicalDevice REF Device ); 

      [Experimental, Description (
          "Expose a single SCSI logical unit (such as a RAID volume or "
          "tape drive) to initiators. One or more paths to the logical "
          "unit may be exposed since multiple target and initiator "
          "port IDs can be included in a single call. Some parameters "
          "are optional, giving the client different levels of "
          "control. For example, if the caller passes in a null "
          "SCSIProtocolController (SPC) reference parameter, the "
          "instrumentation determines whether the new path(s) should "
          "be added to an existing SPC or a new SPC is needed. "
          "Alternatively, the client can provide an SPC reference and "
          "the instrumentation must either add associations to that "
          "SPC or return an error if honoring this request would "
          "violate SCSI semantics. \n"
          "\n"
          "The relevant rules of SCSI semantics are: \n"
          "- an SPC MAY NOT be exposed through a particular "
          "host/target port pair that is in use by another SPC. (In "
          "other words, an SPC corresponds to the logical unit "
          "inventory provided by SCSI REPORT LUNS and INQUIRY "
          "commands) \n"
          "- each LogicalDevice associated to an SPC MUST have a "
          "unique ProtocolControllerForUnit DeviceNumber (logical unit "
          "number) \n"
          "The instrumentation must report an error if the client "
          "request would violate one of these rules. \n"
          "\n"
          "One result of this method is that existing port or logical "
          "unit associations may need to be relocated to a new SPC in "
          "order to comply to the rules above. Consider a "
          "configuration with a single logical unit exposed to two "
          "initiators. If this method is called requesting a new "
          "logical unit be exposed to one of these initiators, then a "
          "new SP must be instantiated so that one SPC has a single "
          "associated volume exposed to one initiator and the other "
          "SPC has both logical units exposed to the other initiator. "
          "\n\n"
          "If the instrumentation provides PrivilegeManagementService, "
          "the results of setting DeviceAccess MUST be synchronized "
          "with PrivilegeManagementService as described in the "
          "ProtocolControllerForUnit DeviceAccess description."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6..4095", "4096",
          "4097", "4098", "4099", "4100", "4101", "4102",
          "4103..32767", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unspecified Error",
          "Timeout", "Failed", "Invalid Parameter", "DMTF Reserved",
          "Invalid logical unit ID", "Invalid initiator port ID",
          "Invalid target port ID", "Invalid permission",
          "Host/initiator combination already exposed",
          "Requested logical unit number in use",
          "Maximum Map Count Exceeded", "Method Reserved",
          "Vendor Specific" }]
   uint32 ExposePaths ( 
         [IN, OUT, Description (
             "Reference to the job (may be null if job completed).")]
      CIM_ConcreteJob REF Job, 
         [Required, IN, Description (
             "ID of the logical unit instance. The LU instance must "
             "already exist."), 
          ModelCorrespondence { "CIM_LogicalDevice.Name" }]
      string LUID, 
         [IN, Description (
             "IDs of initiator ports. If existing StorageHardwareID "
             "instances exist, they MUST be used. If no "
             "StorageHardwareID instance matches, then one is "
             "implicitly created. If this parameter is null, the "
             "logical unit is exposed to all initiators."), 
          ModelCorrespondence { "CIM_StorageHardwareID.StorageID" }]
      string InitiatorPortIDs[], 
         [IN, Description (
             "IDs of target port. Null parameter means that paths "
             "through all target ports should be exposed."), 
          ModelCorrespondence { "CIM_SCSIProtocolEndpoint.Name" }]
      string TargetPortIDs[], 
         [IN, Description (
             "The logical unit number to assign to the logical unit "
             "(within the context of the elements specified in the "
             "other parameters."), 
          ModelCorrespondence { 
             "CIM_ProtocolControllerForUnit.DeviceNumber" }]
      string DeviceNumber, 
         [IN, Description (
             "The permissions to assign to the logical unit (within "
             "the context of the elements specified in the other "
             "parameters."), 
          ValueMap { "0", "2", "3", "4", "5..15999", "16000.." }, 
          Values { "Unknown", "Read Write", "Read-Only", "No Access",
             "DMTF Reserved", "Vendor Reserved" }, 
          ModelCorrespondence { 
             "CIM_ProtocolControllerForUnit.DeviceAccess" }]
      uint16 DeviceAccess, 
         [IN ( false ), OUT, Description (
             "Reference to a SCSIProtocolController (SPC). If this is "
             "null on input, the instrumentation will determine "
             "whether to create a new SPC instance or add associations "
             "to an existing one. If a valid SPC references is passed "
             "in and SCSI semantics can be preserved, the "
             "instrumentation must attach associations to the "
             "specified SPC.")]
      CIM_SCSIProtocolController REF ProtocolController); 

      [Experimental, Description (
          "Hide a single SCSI logical unit (such as a RAID volume or "
          "tape drive) to initiators. One or more paths to the logical "
          "logical unit \n"
          "If the instrumentation provides PrivilegeManagementService, "
          "the results of setting DeviceAccess MUST be synchronized "
          "with PrivilegeManagementService as described in the "
          "ProtocolControllerForUnit DeviceAccess description."), 
       ValueMap { "0", "1", "2", "3", "4", "5", "6..4095", "4096",
          "4097", "4098", "4099", "5000..32767", "32768..65535" }, 
       Values { "Success", "Not Supported", "Unspecified Error",
          "Timeout", "Failed", "Invalid Parameter", "DMTF Reserved",
          "Invalid logical unit ID", "Invalid initiator port ID",
          "Invalid target port ID",
          "Host/initiator combination not exposed", "Method Reserved",
          "Vendor Specific" }]
   uint32 HidePaths ( 
         [IN ( false ), OUT, Description (
             "Reference to the job (may be null if job completed).")]
      CIM_ConcreteJob REF Job, 
         [Required, IN, Description (
             "ID of the logical unit instance. The LU instance must "
             "already exist."), 
          ModelCorrespondence { "CIM_LogicalDevice.Name" }]
      string LUID, 
         [IN, Description (
             "IDs of initiator ports. If this parameter is null, "
             "promiscuous access (from any initiator) to the logical "
             "unit is removed, but access to specific initiators is "
             "left in place."), 
          ModelCorrespondence { "CIM_StorageHardwareID.StorageID" }]
      string InitiatorPortIDs[], 
         [IN, Description (
             "IDs of target port. Null parameter means that paths "
             "through all target ports should be hidden."), 
          ModelCorrespondence { "CIM_SCSIProtocolEndpoint.Name" }]
      string TargetPortIDs[] ); 

};


// ==================================================================
// ProtocolControllerMaskingCapabilities
// ==================================================================
   [Version ( "2.8.1000" ), Description (
       "A subclass of Capabilities that defines the Masking-related "
       "capabilities of a ProtocolController.")]
class CIM_ProtocolControllerMaskingCapabilities : CIM_Capabilities {

      [Description (
          "A list of the valid values for StrorageHardwareID.IDType. "
          "iSCSI IDs may use one of three iSCSI formats - iqn, eui, or "
          "naa. This three letter format is the name prefix; so a "
          "single iSCSI type is provided here, the prefix can be used "
          "to further refine the format."), 
       ValueMap { "1", "2", "3", "4", "5" }, 
       Values { "Other", "Port WWN", "Node WWN", "Host Name",
          "iSCSI Name" }, ArrayType ( "Indexed" )]
   uint16 ValidHardwareIdTypes[];

      [Description (
          "An array of strings describing types for valid "
          "StorageHardwareID.IDType. Used when the "
          "ValidHardwareIdTypes includes 1 (\"Other\")."), 
       ArrayType ( "Indexed" )]
   string OtherValidHardwareIDTypes[];

      [Description (
          "An integer enumeration indicating the way that ports per "
          "view (ProtocolController) are handled by the underlying "
          "storage system."), 
       ValueMap { "2", "3", "4" }, 
       Values { "One Port per View", "Multiple Ports per View",
          "All Ports share the same View" }]
   uint16 PortsPerView = 2;

      [Description (
          "Set to true if this storage system allows the client to "
          "specify the DeviceNumber parameter when calling "
          "ControllerConfigurationService.AttachDevice() and "
          "ControllerConfigurationService.AttachDevice() and Set to "
          "false if the implementation does not allow unit numbers to "
          "vary for a ProtocolController. However, if set to false and "
          "a Device is not the Dependent of a "
          "ProtocolControllerForUnit association, the client must "
          "provide a DeviceNumber parameter in "
          "ControllerConfigurationService.AttachDevice. If set to "
          "false and the Device is already the Dependent of a "
          "ProtocolControllerForUnit association, then the client can "
          "omit the DeviceNumber parameter (or supply the same value) "
          "in subsequent ControllerConfigurationService.AttachDevice "
          "calls.")]
   boolean ClientSelectableDeviceNumbers = TRUE;

      [Description (
          "Set to true if this storage system supports the "
          "AttachDevice method.")]
   boolean AttachDeviceSupported;

      [Description (
          "Set to true if this storage system limits configurations to "
          "a single subject hardware ID per view. Otherwise, multiple "
          "hardware ID types can be used. The default is FALSE, that "
          "multiple ID types may be used in a single view.")]
   boolean OneHardwareIDPerView = FALSE;

      [Description (
          "When set to false, different ProtocolContollers attached to "
          "a LogicalPort can expose the same unit numbers. If true, "
          "then this storage system requires unique unit numbers "
          "across all the ProtocolControllers connected to a "
          "LogicalPort.")]
   boolean UniqueUnitNumbersPerPort = FALSE;

      [Description (
          "Set to true if this storage system allows a client to "
          "create a Privilege instance with PrivilegeGranted set to "
          "FALSE.")]
   boolean PrivilegeDeniedSupported = FALSE;

      [Description (
          "If true, this property indicates that a Privilege/Identity "
          "pair MUST be specified when "
          "CreateProtocolControllerWithPorts() is called. If false, "
          "then the Privilege/Identity pair in "
          "CreateProtocolControllerWithPorts() MUST NOT be set.")]
   boolean ProtocolControllerRequiresAuthorizedIdentity = FALSE;

      [Description (
          "If true, this property indicates that the Identity "
          "parameter of CreateProtocolConntrollerWithPorts() MUST "
          "contain a reference to a CIM_Collection (or subclass) or to "
          "a CIM_Identity (or subclass).")]
   boolean ProtocolControllerSupportsCollections = FALSE;

      [Experimental, Description (
          "Set to true if this storage system supports the ExposePaths "
          "and HidePaths methods.")]
   boolean ExposePathsSupported;

      [Experimental, Description (
          "Set to true if this storage system supports the "
          "CreateProtocolControllerWithPorts method.")]
   boolean CreateProtocolControllerSupported;

      [Experimental, Description (
          "The maximum number of ProtocolCOntrollerForUnit "
          "associations that can be associated with a single "
          "LogicalDevice (for example, StorageVolume). Zero indicates "
          "there is no limit.")]
   uint16 MaximumMapCount = 0;
};


// ===================================================================
// end of file
// ===================================================================
