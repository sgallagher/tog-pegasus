// ===================================================================
// Title:       Device Storage Services 2.7.1
// Filename:    Device27_StorageServices.mof
// Version:     2.7.1
// Release:     Preliminary 
// Date:        November 12 2002
// ===================================================================
// Copyright 2002 Distributed Management Task Force, Inc. (DMTF).
// All rights reserved.  
// DMTF is a not-for-profit association of industry members dedicated 
// to promoting enterprise and systems management and interoperability. 
// DMTF specifications and documents may be reproduced for uses
// consistent with this purpose by members and non-members, 
// provided that correct attribution is given. 
// As DMTF specifications may be revised from time to time, 
// the particular version and release date should always be noted.
//
// Implementation of certain elements of this standard or proposed 
// standard may be subject to third party patent rights, including 
// provisional patent rights (herein "patent rights"). DMTF makes 
// no representations to users of the standard as to the existence 
// of such rights, and is not responsible to recognize, disclose, or
// identify any or all such third party patent right, owners or 
// claimants, nor for any incomplete or inaccurate identification or 
// disclosure of such rights, owners or claimants. DMTF shall have no 
// liability to any party, in any manner or circumstance, under any 
// legal theory whatsoever, for failure to recognize, disclose, or 
// identify any such third party patent rights, or for such party's
// reliance on the standard or incorporation thereof in its product, 
// protocols or testing procedures. DMTF shall have no liability to 
// any party implementing such standard, whether such implementation 
// is foreseeable or not, nor to any patent owner or claimant, and shall 
// have no liability or responsibility for costs or losses incurred if 
// a standard is withdrawn or modified after publication, and shall be
// indemnified and held harmless by any party implementing the 
// standard from any and all claims of infringement by a patent owner 
// for such implementations.
//
// For information about patents held by third-parties which have 
// notified the DMTF that, in their opinion, such patent may relate to 
// or impact implementations of DMTF standards, visit 
// http://www.dmtf.org/about/policies/disclosures.php.
// ===================================================================
// Description: The Device Model extends the management concepts that
//              are related to LogicalDevices. This file defines
//              a model for storage services.
//
//              The object classes below are listed in an order that
//              avoids forward references. Required objects, defined 
//              by other working groups, are omitted.
// ==================================================================
// Change Log for v2.7.1
// CR914 - Define the MaxValue qualifier (as 10) for 
//         AccessBandwidthWeight and AccessDirectionHint in 
//         StorageSettingWithHints
// CR920 - StorageConfigurationService.ModifySynchronization's Operation
//         parameter requires a comma in its Values array after
//         "Restore From Replica"
//
// Change Log for v2.7
// CR775 - Add StorageSetting, StoragePool, StorageCapabilities,
//         StorageConfigurationService, StorageSettingsWithHints,
//         HostedStoragePool, and AllocatedStoragePool
// CR759 - Add ConfigurationReportingService
// CR777 - Add StorageSynchrononized 
//         Add StorageSetting.DeltaReservation, 
//         StorageCpabilities.DeltaReservationMin, 
//         StorageCpabilities.DeltaReservationMax, 
//         StorageCpabilities.DeltaReservationDefault, 
//         StorageConfigurationService.CreateReplica() and 
//         StorageConfigurationService.ModifySynchronization()
// CR895 - Correct the method return Values/ValueMaps for all the
//         methods in the ConfigurationReportingService.
// ================================================================== 

#pragma locale ("en_US")


// ==================================================================
// StorageSynchrononized
// ==================================================================
[Association, Experimental, Version ("2.7.0"), Description (
    "Indicates that two Storage objects were replicated "
    "at the specified point in time. If the CopyType "
    "property is set to 'Sync' (=3), then synchronization "
    "of the Storage objects is preserved.") ]
class CIM_StorageSynchronized : CIM_Synchronized {

    [Override("SystemElement"), Description (
        "SystemElement represents the Storage that is "
        "the source of the replication.") ]
    CIM_LogicalElement REF SystemElement;

    [Override("SyncedElement"), Description (
        "SyncedElement represents the Storage that is "
        "the target of the replication.") ]
    CIM_LogicalElement REF SyncedElement;

    [Description (
        "CopyType describes the Replication Policy. "
        "Values are:  \n"
        "  Async: create and maintain an asynchronous "
        "copy of the source. \n"
        "  Sync: create and maintain a synchronized copy "
        "of the source. \n"
        "  UnSyncAssoc: create an unsynchronized copy and "
        "maintain an association to the source."),
        ValueMap {"2", "3", "4", "..", "0x8000.."},
        Values {"Async", "Sync", "UnSyncAssoc", 
            "DMTF Reserved", "Vendor Specific"} ]
    uint16 CopyType;
};


// ==================================================================
// StorageSetting                                                     
// ==================================================================
[Experimental, Version ("2.7.0"), Description (
    "StorageSetting is roughly equivalent to a Service Level "
    "Agreement (SLA) when associated by ElementSetting "
    "to a StorageVolume.  StorageSetting is a Service "
    "Level Objective (SLO) when used in a StartCreateStorageVolume "
    "method. It defines a series of properties with Maximum and "
    "Minimum values that the object should maintain.") ]
class CIM_StorageSetting : CIM_SettingData {
        
    [Write, Description (
        "Indicates the desired value for No Single Point of Failure. "
        "Possible values are false = single point of failure, and "
        "true = no single point of failure.") ]
    boolean NoSinglePointOfFailure;

    [Write, MinValue(1), Description (
        "DataRedundancyMax describes the maximum number of complete "
        "copies of data to be maintained. Examples would be RAID 5 "
        "where 1 copy is maintained and RAID 1 where 2 or more copies "
        "are maintained.  Possible values are 1 to n."),
        ModelCorrespondence {"CIM_StorageSetting.DataRedundancyMin"} ]
    uint16 DataRedundancyMax;

    [Write, MinValue(1), Description (
        "DataRedundancyMin describes the minimum number of complete "
        "copies of data to be maintained. Examples would be RAID 5 "
        "where 1 copy is maintained and RAID 1 where 2 or more copies "
        "are maintained. Possible values are 1 to n."), 
        ModelCorrespondence {"CIM_StorageSetting.DataRedundancyMax"} ]
    uint16 DataRedundancyMin;

    [Write, Description (
        "SpindleRedundancyMax describes the maximum number of spindles "
        "to be used. Spindle redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. Examples would be RAID5 with a Spindle Redundancy of "
        "1, RAID6 with 2, RAID 6 with 2 spares would be 3. Possible "
        "values are 0 to n."),
        ModelCorrespondence {"CIM_StorageSetting.SpindleRedundancyMin"} ]
    uint16 SpindleRedundancyMax;

    [Write, Description (
        "SpindleRedundancyMin describes the minimum number of spindles "
        "to be used. Spindle redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. Examples would be RAID5 with a Spindle Redundancy of "
        "1, RAID6 with 2, RAID 6 with 2 spares would be 3. Possible "
        "values are 0 to n."),
        ModelCorrespondence {"CIM_StorageSetting.SpindleRedundancyMax"} ]
    uint16 SpindleRedundancyMin;
    
    [MinValue (1), MaxValue (100), Description (
        "Delta reservation is a number between 1 (1%) and a 100 (100%) "
        "that specifies how much space should reserved in a replica "
        "for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations.") ]
    uint16 DeltaReservation;
};


// ==================================================================
// StoragePool
// ==================================================================
[Experimental, Version ("2.7.0"), Description (
    "A pool of Storage that is managed by a particular "
    "System. StoragePools may consist of component StoragePools or "
    "StorageExtents. StorageExtents/StoragePools that belong to the "
    "StoragePool have a Component relationship to the StoragePool. "
    "StorageExtents/StoragePools that are components of a "
    "pool have their available space aggregated into the pool. "
    "StoragePools and StorageVolumes may be created from StoragePools. "
    "This is indicated by the AllocatedFromStoragePool association. "
    "StoragePool is scoped to a system by the SystemStoragePool "
    "association.") ] 
class CIM_StoragePool : CIM_LogicalElement {
    
    [Key, Description (
        "InstanceID opaquely identifies a unique instance of "
        "StoragePool.  The InstanceID must be unique within a "
        "namespace. In order to ensure uniqueness, the value of "
        "InstanceID SHOULD be constructed in the following manner: \n"
        "<Vendor ID><ID> \n"
        "   <Vendor ID> MUST include a copyrighted, trademarked "
        "or otherwise unique name that is owned by the business "
        "entity or a registered ID that is assigned to the business "
        "entity that is defining the InstanceID. (This is similar to "
        "the <Schema Name>_<Class Name> structure of Schema class "
        "names.) The purpose of <Vendor ID> is to ensure that <ID> is "
        "truly unique across multiple vendor implementations.   "
        "If such a name is not used, the defining entity MUST assure "
        "that the <ID> portion of the Instance ID is unique when "
        "compared with other instance providers. For DMTF defined "
        "instances, the <Vendor ID> is 'CIM'. \n"
        "   <ID> MUST include a vendor specified unique "
        "identifier.") ]        
    string InstanceID;

    [Required, MaxLen (256), Description (
        "A unique name in the context of the System that "
        "identifies this pool.") ]
    string PoolID;

    [Description (
        "For pools that support discrete sizes for volume or "
        "pool creation, this method can be used to retrieve a "
        "list of supported sizes. Note that different pool "
        "implementations may support either or both the "
        "GetSupportedSizes and GetSupportedSizeRanges at different "
        "times, depending on Pool configuration. Also note that the "
        "advertised size may change after the call due to requests "
        "from other clients. If the pool currently only supports a "
        "range of sizes, then the return value will be set to 1."),
        ValueMap {"0", "1", "2"},
        Values {"Method completed OK", "Method not supported",
            "Use GetSupportedSizeRange instead"} ]
    uint32 GetSupportedSizes (
        [IN, Description (
            "Specifies the size requirements.") ]
        CIM_StorageSetting REF Goal,
        [OUT, IN(false), Description (
            "List of support sizes for a Volume/Pool creation or "
            "modification."),
            Units ("MegaBytes") ]
        uint64  Sizes[] );

    [Description (
        "For pools that that support a range of sizes for volume or "
        "pool creation, this method can be used to retrieve the "
        "supported range. Note that different pool implementations "
        "may support either or both the GetSupportedSizes and "
        "GetSupportedSizeRanges at different times, depending on Pool "
        "configuration. Also note that the advertised size may change "
        "after the call due to requests from other clients. If the "
        "pool currently only supports discrete sizes, then the return "
        "value will be set to 1."),
        ValueMap {"0", "1", "2"},
        Values {"Method completed OK", "Method not supported",
            "Use GetSupportedSizes instead"} ]
    uint32 GetSupportedSizeRange (
        [IN, Description (
            "Specifies the size requirements.") ]
        CIM_StorageSetting REF Goal,
        [OUT, IN(false), Description (
            "The minimum size for a volume/pool."),
            Units ("MegaBytes") ]
        uint64  MinimumVolumeSize,
        [OUT, IN(false), Description (
            "The maximum size for a volume/pool."),
             Units ("MegaBytes") ]
        uint64  MaximumVolumeSize,
        [OUT, IN(false), Description (
            "A volume/pool size must be a multiple of this value."),
            Units ("MegaBytes") ]
        uint64  VolumeSizeDivisor);

    [Description (
         "Raw available space in the pool."), Units("MegaBytes") ]
    uint64 TotalAvailableSpace;
};  

 
// ==================================================================
// StorageCapabilities
// ==================================================================
[Experimental, Version ("2.7.0"), Description (
    "A subclass of Capabilities that defines the " 
    "Capabilities of a StorageService or StoragePool. "
    "For example, an instance of StorageCapabilities could be"
    "associated with either a StorageConfigurationService or "
    "StoragePool by using ElementCapabilities.") ]
class CIM_StorageCapabilities : CIM_Capabilities {

    [Description (
        "Enumeration indicating the type of instance to which this "
        "StorageCapabilities applies."),
        ValueMap{"0", "1", "2", "3", "4", "5", "6"},
        Values {"Unknown", "Reserved", "Any Type", "StorageVolume", 
            "StorageExtent", "StoragePool", 
            "StorageConfigurationService"} ]
    uint16 InstanceType;

    [Description (
        "Indicates whether or not the associated instance supports "
        "no single point of failure.  Values are: "
        "FALSE = does not support no single point of failure, "
        "and TRUE = supports no single point of failure.") ]
    boolean NoSinglePointOfFailure;

    [Description (
        "Indicates the default value for the NoSinglePointOfFailure "
        "property."),
        ModelCorrespondence {
            "CIM_StorageCapabilities.NoSinglePointOfFailure"} ]
    boolean NoSinglePointOfFailureDefault;

    [MinValue (1), Description (
        "DataRedundancyMax describes the maximum number of complete "
        "copies of data that can be maintained. Examples would be "
        "RAID 5 where 1 copy is maintained and RAID 1 where 2 or "
        "more copies are maintained.  Possible values are 1 to n."),
        ModelCorrespondence {"CIM_StorageCapabilities.DataRedundancyMin"} ]
    uint16 DataRedundancyMax;

    [MinValue (1), Description (
        "DataRedundancyMin describes the minimum number of complete "
        "copies of data that can be maintained. Examples would be "
        "RAID 5 where 1 copy is maintained and RAID 1 where 2 or "
        "more copies are maintained.  Possible values are 1 to n."),
        ModelCorrespondence {"CIM_StorageCapabilities.DataRedundancyMax"} ]
    uint16 DataRedundancyMin;

    [MinValue(1), Description (
        "DataRedundancyDefault describes the default number of "
        "complete copies of data that can be maintained. Examples "
        "would be RAID 5 where 1 copy is maintained and RAID 1 where "
        "2 or more copies are maintained.  Possible values are "
        "1 to n.") ]
    uint16 DataRedundancyDefault;

    [Description (
        "SpindleRedundancyMax describes the maximum number of spindles "
        "that can be used.  Spindle redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. Examples would be RAID5 with a Spindle Redundancy of "
        "1, RAID6 with 2, RAID 6 with 2 spares would be 3. Possible "
        "values are 0 to n."), 
        ModelCorrespondence {
            "CIM_StorageCapabilities.SpindleRedundancyMin"} ]
    uint16 SpindleRedundancyMax;

    [Description (
        "SpindleRedundancyMin describes the minimum number of spindles "
        "that can be used.  Spindle redundancy describes how many disk "
        "spindles can fail without data loss including, at most, one "
        "spare. Examples would be RAID5 with a Spindle Redundancy of "
        "1, RAID6 with 2, RAID 6 with 2 spares would be 3. Possible "
        "values are 0 to n."),
        ModelCorrespondence {
            "CIM_StorageCapabilities.SpindleRedundancyMax"} ]
    uint16 SpindleRedundancyMin;

    [Description (
        "SpindleRedundancyDefault describes the default number of "
        "spindles that can be used. Spindle redundancy describes "
        "how many disk spindles can fail without data loss including, "
        "at most, one spare. Examples would be RAID5 with a Spindle "
        "Redundancy of 1, RAID6 with 2, RAID 6 with 2 spares would be "
        "3. Possible values are 0 to n.") ]
    uint16 SpindleRedundancyDefault;

    [MinValue (1), MaxValue (100), Description (
        "Delta reservation is a number between 1 (1%) and a 100 (100%) "
        "that specifies how much space should be reserved in a replica "
        "for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations. This parameter "
        "sets the upper limit."),
        ModelCorrespondence {
            "CIM_StorageCapabilities.DeltaReservationMin"} ]
    uint16 DeltaReservationMax;

    [MinValue (1), MaxValue (100), Description (
        "Delta reservation is a number between 1 (1%) and a 100 (100%) "
        "that specifies how much space should be reserved in a replica "
        "for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations. This parameter "
        "sets the lower limit."), 
        ModelCorrespondence {
            "CIM_StorageCapabilities.DeltaReservationMax"} ]
    uint16 DeltaReservationMin;

    [MinValue (1), MaxValue (100), Description (
        "Delta reservation is a number between 1 (1%) and a 100 (100%) "
        "that specifies how much space should be reserved in a replica "
        "for caching changes. For a complete copy this would be 100%, "
        "but it can be lower in some implementations. This parameter "
        "sets the default value.") ]
    uint16 DeltaReservationDefault;
};


// ==================================================================
// StorageConfigurationService 
// ==================================================================
[Experimental, Version ("2.7.1"), Description (
    "This service allows the active management of a Storage "
    "Server. It allows jobs to be started for the creation, "
    "modification and deletion of storage objects (StoragePools "
    "and StorageVolumes).") ]
class CIM_StorageConfigurationService : CIM_Service {

    [Description (
        "Starts a job to create (or modify) a StoragePool.  The "
        "StoragePool will be (or must be) scoped to the same System "
        "as this Service. One of the parameters for this method is "
        "Size. As an input parameter, Size specifies the desired size. "
        "As an output parameter, Size specifies the size achieved. "
        "Space is taken from either or both of the specified input "
        "StoragePools and StorageExtents (InPools and InExtents). "
        "The capability requirements that the Pool must support "
        "are defined using the Goal parameter. If the requested "
        "pool size cannot be created, no action will be taken, the "
        "Return Value will be 0x1002, and the output value of "
        "Size will be set to the nearest possible size. If 0 is "
        "returned, then the task completed successfully and the "
        "use of ConcreteJob was not required. If the task will take "
        "some time to complete, a ConcreteJob will be created "
        "and its reference returned in the output paramter Job."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", 
            "0x1000", "0x1001", "0x1002..0x7777", "0x8000.."},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Size Not Supported", "Method Reserved", 
            "Vendor Specific"} ]
    uint32 CreateOrModifyStoragePool ( 
        [OUT, IN(false), Description (
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description (
            "Reference to an instance of StorageSetting that defines "
            "the desired capabilities of the StoragePool. If set to a "
            "null value, the default configuration from the source "
            "pool will be used.") ]
        CIM_StorageSetting REF Goal,
        [IN, OUT, Description (
            "As an input parameter this specifies the desired pool size. "
            "As an output parameter this specifies the size "
            "achieved.") ] 
        uint64 Size,
        [IN, Description (
           "Array of strings containing representations of "
           "references to CIM_StoragePool instances, that are used "
           "to create the Pool.") ]
        string InPools[],
        [IN, Description (
           "Array of strings containing representations of "
           "references to CIM_StorageExtent instances, that are used "
           "to create the Pool.") ]
        string InExtents[],
        [IN, OUT, Description (
            "As an input parameter: if null, creates a new StoragePool. "
            "If not null, modifies the Pool. When returned, it is a "
            "reference to the resulting StoragePool.") ] 
        CIM_StoragePool REF Pool);

    [Description (
        "Start a job to create (or modify) a specified element (for "
        "example a StorageVolume, StorageExtent, or StoragePool) from "
        "a StoragePool. One of the parameters for this method is "
        "Size. As an input parameter, Size specifies the desired size. "
        "As an output parameter, Size specifies the size achieved. "
        "Space is taken from the input StoragePool. The desired "
        "settings for the element are specified by the Goal parameter. "
        "If the requested size cannot be created, no action "
        "will be taken, and the Return Value will be 0x1001. Also, "
        "the output value of Size is set to the nearest possible "
        "size. If 0 is returned, the function completed successfully "
        "and no ConcreteJob instance was required.  If 0x1000 is "
        "returned, a ConcreteJob will be started to create the "
        "element. The Job's reference will be returned in the "
        "output paramter Job."), 
        ValueMap {"0", "1", "2", "3", "4", "5", "..", 
            "0x1000", "0x1001", "0x1002..0x7777", "0x8000.."},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Size Not Supported", "Method Reserved",
            "Vendor Specific"} ]
    uint32 CreateOrModifyElementFromStoragePool(
        [IN, Description (
            "Enumeration indicating the type of element being created "
            "or modified. If the input parameter Element is specified "
            "when the operation is a 'modify', this type value must "
            "match the type of that instance."),
            ValueMap{"0", "1", "2", "3", "..", "0x8000.."},
            Values {"Unknown", "Reserved", "StorageVolume", 
                "StorageExtent", "DMTF Reserved", "Vendor Specific"} ]
        uint16 ElementType,
        [OUT, IN(false), Description (
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description (
            "The requirements for the element to maintain. If set to "
            "a null value, the default configuration from the source "
            "pool will be used.") ]
        CIM_StorageSetting REF Goal,
        [IN, OUT, Description (
            "As an input parameter Size specifies the desired size. "
            "As an output parameter Size specifies the size "
            "achieved.") ] 
        uint64 Size,
        [IN, Description (
            "The Pool from which to create the element. This parameter "
            "must be set to null if the input parameter Element is "
            "specified (in the case of a 'modify' operation).") ] 
        CIM_StoragePool REF InPool,
        [IN, OUT, Description (
            "As an input parameter: if null, creates a new element. If "
            "not null, then the method modifies the specified element. "
            "As an output parameter, it is a reference to the "
            "resulting element.") ] 
        CIM_LogicalElement REF TheElement);

    [Description (
        "Start a job to delete a StoragePool. The freed space is "
        "returned to the source StoragePool.  If 0 is returned, the "
        "function completed successfully, and no ConcreteJob was "
        "required. If 0x1000 is returned, a ConcreteJob will be started "
        "to delete the StoragePool. A reference to the Job is returned "
        "in the Job parameter."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", "0x1000",
            "0x1001..0x7777", "0x8000.."},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Method Reserved", "Vendor Specific"} ]
    uint32 DeleteStoragePool (
        [OUT, IN(false), Description (
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description (
            "Reference to the pool to delete.") ] 
        CIM_StoragePool REF Pool);

    [Description (
        "Start a job to delete an element previously created from a "
        "StoragePool. The freed space is returned to the source "
        "StoragePool. If 0 is returned, the function completed "
        "successfully and no ConcreteJob was required. If 0x1000 is "
        "returned, a ConcreteJob will be started to delete the element. "
        "A reference to the Job is returned in the Job parameter."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", "0x1000",
            "0x1001..0x7777", "0x8000.."},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Method Reserved", "Vendor Specific"} ]
    uint32 ReturnToStoragePool(
        [OUT, IN(false), Description (
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description (
            "Reference to the element to return to the StoragePool.") ] 
        CIM_LogicalElement REF TheElement);

    [Description (
        "Start a job to create a new storage object which "
        "is a replica of the source storage object. Note that using "
        "the input paramter, CopyType, this function can be used to "
        "instantiate the replica, and to create an ongoing "
        "association between the source and replica. If 0 is "
        "returned, the function completed successfully and "
        "no ConcreteJob instance is created. If 0x1000 is returned, "
        "a ConcreteJob is started, a reference to which is "
        "returned in the Job output parameter."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", "0x1000",
            "0x1001..0x7777", "0x8000.."},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "DMTF Reserved", "Method Parameters Checked - Job Started",
            "Method Reserved", "Vendor Specific"} ]
    uint32 CreateReplica(
        [OUT, IN(false), Description (
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Required, Description (
            "The source storage object.") ]
        CIM_LogicalElement REF SourceElement,
        [OUT, IN(false), Description (
            "Reference to the created target storage element "
            "(i.e., the replica).") ]
        CIM_LogicalElement REF TargetElement,
        [IN, Description (
            "The definition for the StorageSetting to be maintained "
            "by the target storage object (the replica).") ]
        CIM_StorageSetting REF TargetSettingGoal,
        [IN, Description (
            "The underlying storage for the target element (the "
            "replica) will be drawn from TargetPool if specified, "
            "otherwise the allocation is implementation specific.") ] 
        CIM_StoragePool REF TargetPool,
        [IN, Description (
            "CopyType describes the type of copy that will be made. "
            "Values are: \n "
            "  Async: Create and maintain an asynchronous "
            "copy of the source. \n "
            "  Sync: Create and maintain a synchronized copy "
            "of the source. \n" 
            "  UnSyncAssoc: Create an unsynchronized copy and "
            "maintain an association to the source. \n "
            "  UnSyncUnAssoc: Create unassociated copy of the "
            "source element."),
            ValueMap {"2", "3", "4", "5", "..", "0x8000.."},
            Values {"Async", "Sync", "UnSyncAssoc", "UnSyncUnAssoc",
                "DMTF Reserved", "Vendor Specific"} ]
        uint16 CopyType);

    [Description (
        "Starts a job to modify the synchronization association "
        "between two storage objects. If 0 is returned, the "
        "function completed successfully and no ConcreteJob "
        "instance was created. If 0x1000 is returned, a ConcreteJob "
        "was started. A reference to this Job is returned in "
        "the Job output parameter."),
        ValueMap {"0", "1", "2", "3", "4", "5", "..", "0x1000",
            "0x1001..0x7777", "0x8000.."},
        Values {"Job Completed with No Error", "Not Supported", 
            "Unknown", "Timeout", "Failed", "Invalid Parameter", 
            "DMTF Reserved", 
            "Method Parameters Checked - Job Started",
            "Method Reserved", "Vendor Specific"} ]
    uint32 ModifySynchronization(
        [IN, Description (
            "Operation describes the type of modification "
            "to be made to the replica. Values are: \n "
            "  Detach: 'Forget' the synchronization between "
            "two storage objects. Start to treat the objects as "
            "independent. \n "
            "  Fracture: Suspend the synchronization between "
            "two storage objects. The association and "
            "(typically) changes are remembered to allow a fast "
            "resynchronization. This may be used during "
            "a backup cycle to allow one of the objects to be "
            "copied while the other remains in production. \n"
            "  Resync Replica: Re-establish the synchronization of "
            "a replica. If CopyJob is Sync or Async, this will "
            "negate the action of a previous Fracture operation. \n"
            "  Restore from Replica: Renew the contents of "
            "the original storage object from a replica."),
            ValueMap {"0","1","2", "3", "4", "5", "..", "0x8000.."},
            Values {" DMTF Reserved", "DMTF Reserved", "Detach", 
                 "Fracture", "Resync Replica", "Restore from Replica",
                 "DMTF Reserved", "Vendor Specific"} ]
        uint16 Operation,
        [OUT, IN(false), Description (
            "Reference to the job (may be null if job completed).") ]
        CIM_ConcreteJob REF Job,
        [IN, Description (
            "The referenced to the StorageSynchronized association "
            "describing the storage source/replica relationship.") ]
        CIM_StorageSynchronized REF Synchronization);
};


// ====================================================================
// StorageSettingWithHints
// ====================================================================
[Experimental, Version("2.7.1"), Description (
    "This subclass of StorageSetting allows a client to specify "
    "'hint's for optimization of the volume performance. The effect "
    "of these hints is implementation dependent.") ]
class CIM_StorageSettingWithHints: CIM_StorageSetting {
    
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of the importance "
        "placed on data availability. Values are 0=Don't Care to "
        "10=Very Important.") ]
    uint16 DataAvailabilityHint;
        
    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of the randomness "
        "of accesses. Values are 0=Entirely Sequential to "
        "10=Entirely Random.") ]
    uint16 AccessRandomnessHint;

    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of the direction "
        "of accesses. Values are 0=Entirely Read to "
        "10=Entirely Write.") ]
    uint16 AccessDirectionHint;

    [Description (
        "This hint is an indication from a client of the optimal "
        "access sizes.  Several sizes can be specified."),
        Units ("MegaBytes") ]
    uint16 AccessSizeHint[];

    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client how important "
        "access latency is. Values are 0=Don't Care to "
        "10=Very Important.") ]
    uint16 AccessLatencyHint;

    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication from a client of bandwidth "
        "prioritization. Values are 0=Don't Care to "
        "10=Very Important.") ]
    uint16 AccessBandwidthWeight;

    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication of the importance the client "
        "places on the cost of storage. Values are 0=Don't Care to "
        "10=Very Important. A StorageVolume provider might choose "
        "to place data on low cost or high cost drives based on "
        "this parameter.") ]
    uint16 StorageCostHint;

    [MinValue (0), MaxValue (10), Description (
        "This hint is an indication of the importance placed on "
        "storage efficiency by the client. Values are 0=Don't Care "
        "to 10=Very Important. A StorageVolume provider might choose "
        "different RAID levels based on this hint.") ]
    uint16 StorageEfficiencyHint;
};


// ==================================================================
// HostedStoragePool
// ==================================================================
[Association, Aggregation, Experimental, Composition, 
    Version ("2.7.0"), Description (
        "SystemStoragePool is a specialization of SystemComponent "
        "association that establishes that the StoragePool is "
        "defined in the context of the System.") ]
class CIM_HostedStoragePool : CIM_SystemComponent {
        
    [Override ("GroupComponent"), Aggregate, Max (1), Min (1), 
        Description ("The parent system in the Association.") ] 
    CIM_System REF GroupComponent;
 
    [Override ("PartComponent"), Description (
        "The StoragePool that is a component of a System.") ] 
    CIM_StoragePool REF PartComponent;
};


// ===================================================================
// AllocatedFromStoragePool
// ===================================================================
[Association, Experimental, Version ("2.7.0"), Description (
    "AllocatedFromStoragePool is an association describing how "
    "LogicalElements are allocated from underlying StoragePools. "
    "These elements typically would be subclasses of StorageExtents "
    "or StoragePools.") ] 
class CIM_AllocatedFromStoragePool : CIM_Dependency {
    
    [Override ("Antecedent"), 
        Description ("The StoragePool.") ]
    CIM_StoragePool REF Antecedent;

    [Override ("Dependent"),
        Description ("The subsidiary element.") ]
    CIM_LogicalElement REF Dependent;

    [Description (
        "Space Consumed from this Pool"), Units("MegaBytes") ]
    uint64 SpaceConsumed;
};


// ===================================================================
// ConfigurationReportingService
// ===================================================================
[Experimental, Description (
    "Service to provide reports on current configuration and "
    "potential for growth. The service may be used in several "
    "circumstances: \n"
    "- To report growth potential (how many can I have) \n"
    "- To report information on objects not directly modeled for "
    "performance or other reasons. \n "
    "It can also report counts of 'things' or counts of 'units'. "
    "For example, the number of disk drives could be reported or the "
    "capacity that they would provide.") ]
class CIM_ConfigurationReportingService : CIM_Service {

    [Description (
        "Returns a list of classes that the given Managed"
        "Element supports or has installed."), 
        ValueMap {"0", "1", "2", "3", "4", "..", "0x8000.."},
        Values {"Success", "Not Supported", "Unknown",
            "Timeout", "Failed", "DMTF Reserved",
            "Vendor Specific"} ]
    uint32 GetClassTypes(
        [IN, ValueMap {"2", "3"}, 
            Values {"Supports", "Installed"},
            Description (
                "The type of inquiry to be performed.") ] 
        uint16 InquiryType,
        [IN, Description (
            "False : Only report on elements directly contained "
            "in/attached to the given ManagedElement. \n"
            "True : Report on all objects contained in/attached "
            "to the given ManagedElement.") ]
        boolean Recursive,
        [IN, Description (
            "The target of query, for example a rack or a chassis.") ]
        CIM_ManagedElement REF Target,
        [OUT, IN (false), Description (
            "Array containing the class names (typically the leaf "
            "classes) that the given ManagedElement can support or "
            "has installed.") ]
        string ClassTypes[]);

    [Description (
        "Returns a list of UnitTypes that are installed for "
        "a given ClassType on a given ManagedElement."),
        ValueMap {"0", "1", "2", "3", "4", "..", "0x8000.."},
        Values {"Success", "Not Supported", "Unknown",
            "Timeout", "Failed", "DMTF Reserved",
            "Vendor Specific"} ]
    uint32 GetUnitTypes(
        [IN, ValueMap {"2", "3"}, 
            Values {"Supported", "Installed"},
            Description ("The type of inquiry to be performed.") ] 
        uint16 InquiryType,
        [IN, Description (
            "False : Only report on elements directly contained "
            "in/attached to the given ManagedElement. \n"
            "True : Report on all objects contained in/attached "
            "to the given ManagedElement.") ]
        boolean Recursive,
        [IN, Description (
            "The target of query, for example a rack or a chassis.") ]
        CIM_ManagedElement REF Target,
        [IN, Description (
            "The ClassType for the query. This should be a entry "
            "returned in the GetClassTypes.ClassTypes property.") ]
        string ClassType,
        [OUT, IN (false), Description (
            "A list of supported UnitTypes."),
            ValueMap{"2", "3", "4", "5", "6", "7", "8", "9", 
                "10", "..", "0x8000.."},
            Values {"None", "Front Side", "Back Side", "Contained",
                "Connected", "I/O", "Memory", "StorageMediaLocation",
                "Megabytes", "DMTF Reserved", "Vendor Specific"},
            ModelCorrespondence {
                "CIM_ConfigurationReportingService."
                "ReportCapacity(UnitType)"} ]
        uint16 UnitTypes[]);

    [Description (
        "Returns the maximum number supported or the "
        "number of currently installed units for the given UnitType, "
        "for a given ClassType on a given ManagedElement."),
        ValueMap {"0", "1", "2", "3", "4", "..", "0x8000.."},
        Values {"Success", "Not Supported", "Unknown",
            "Timeout", "Failed", "DMTF Reserved",
            "Vendor Specific"} ]
    uint32 ReportCapacity(
        [IN, ValueMap {"2", "3"}, 
            Values {"Supported", "Installed"},
            Description ("The type of inquiry to be performed.") ] 
        uint16 InquiryType,
        [IN, Description (
            "False : Only report on elements directly contained "
            "in/attached to the given ManagedElement. \n"
            "True : Report on all objects contained in/attached "
            "to the given ManagedElement.") ]
        boolean Recursive,
        [IN, Description (
            "The target of query, for example a rack or a chassis.") ]
        CIM_ManagedElement REF Target,
        [IN, Description (
            "The ClassType for the query. This should be a entry "
            "returned in the GetClassTypes.ClassTypes property.") ]
        string ClassType,
        [IN, Description (
            "The UnitType for the query."),
            ValueMap{"2", "3", "4", "5", "6", "7", "8", "9",
                "10", "..", "0x8000.."},
            Values {"None", "Front Side", "Back Side", "Contained",
                "Connected", "I/O", "Memory", "StorageMediaLocation",
                "Megabytes", "DMTF Reserved", "Vendor Specific"},
            ModelCorrespondence {
                "CIM_ConfigurationReportingService."
                "GetUnitTypes(UnitTypes)"} ]
        uint16 UnitType,
        [OUT, IN (false), Description (
            "The maximum number of supported or the number of "
            "currently installed units.") ]
        uint64 NumberOfUnits);
};


// ===================================================================
// end of file
// ===================================================================
